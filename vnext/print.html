<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rhai - Embedded Scripting for Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Tutorial and reference on the Rhai scripting engine and language.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about/index.html">What is Rhai</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/features.html">Features</a></li><li class="chapter-item expanded "><a href="about/targets.html">Supported Targets and Builds</a></li><li class="chapter-item expanded "><a href="about/non-design.html">What Rhai Isn't</a></li><li class="chapter-item expanded "><a href="about/related.html">Related Resources</a></li></ol></li><li class="chapter-item expanded "><a href="start/index.html">Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/playground.html">Online Playground</a></li><li class="chapter-item expanded "><a href="start/install.html">Install the Rhai Crate</a></li><li class="chapter-item expanded "><a href="start/features.html">Optional Features</a></li><li class="chapter-item expanded "><a href="start/builds/index.html">Special Builds</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/builds/performance.html">Performance</a></li><li class="chapter-item expanded "><a href="start/builds/minimal.html">Minimal</a></li><li class="chapter-item expanded "><a href="start/builds/no-std.html">no-std</a></li><li class="chapter-item expanded "><a href="start/builds/wasm.html">WebAssembly (WASM)</a></li></ol></li><li class="chapter-item expanded "><a href="start/examples/index.html">Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/examples/rust.html">Rust</a></li><li class="chapter-item expanded "><a href="start/examples/scripts.html">Scripts</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="engine/index.html">Using the Engine</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/hello-world.html">Hello World in Rhai - Evaluate a Script</a></li><li class="chapter-item expanded "><a href="engine/compile.html">Compile a Script to AST for Repeated Evaluations</a></li><li class="chapter-item expanded "><a href="engine/call-fn.html">Call a Rhai Function from Rust</a></li><li class="chapter-item expanded "><a href="engine/func.html">Create a Rust Anonymous Function from a Rhai Function</a></li><li class="chapter-item expanded "><a href="engine/expressions.html">Evaluate Expressions Only</a></li><li class="chapter-item expanded "><a href="engine/raw.html">Raw Engine</a></li></ol></li><li class="chapter-item expanded "><a href="rust/index.html">Extend Rhai with Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/traits.html">Traits</a></li><li class="chapter-item expanded "><a href="rust/functions.html">Register a Rust Function</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/strings.html">String Parameters in Rust Functions</a></li></ol></li><li class="chapter-item expanded "><a href="rust/generic.html">Register a Generic Rust Function</a></li><li class="chapter-item expanded "><a href="rust/fallible.html">Register a Fallible Rust Function</a></li><li class="chapter-item expanded "><a href="rust/packages/index.html">Packages</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/packages/builtin.html">Built-in Packages</a></li><li class="chapter-item expanded "><a href="rust/packages/create.html">Create a Custom Package</a></li></ol></li><li class="chapter-item expanded "><a href="rust/override.html">Override a Built-in Function</a></li><li class="chapter-item expanded "><a href="rust/operators.html">Operator Overloading</a></li><li class="chapter-item expanded "><a href="rust/custom.html">Register a Custom Type and its Methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/getters-setters.html">Getters and Setters</a></li><li class="chapter-item expanded "><a href="rust/indexers.html">Indexers</a></li><li class="chapter-item expanded "><a href="rust/disable-custom.html">Disable Custom Types</a></li><li class="chapter-item expanded "><a href="rust/print-custom.html">Printing Custom Types</a></li></ol></li><li class="chapter-item expanded "><a href="rust/scope.html">Scope - Initializing and Maintaining State</a></li><li class="chapter-item expanded "><a href="rust/options.html">Engine Configuration Options</a></li></ol></li><li class="chapter-item expanded "><a href="language/index.html">Rhai Language Reference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/comments.html">Comments</a></li><li class="chapter-item expanded "><a href="language/values-and-types.html">Values and Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/dynamic.html">Dynamic Values</a></li><li class="chapter-item expanded "><a href="language/type-of.html">type-of()</a></li><li class="chapter-item expanded "><a href="language/numbers.html">Numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/num-op.html">Operators</a></li><li class="chapter-item expanded "><a href="language/num-fn.html">Functions</a></li><li class="chapter-item expanded "><a href="language/convert.html">Value Conversions</a></li></ol></li><li class="chapter-item expanded "><a href="language/strings-chars.html">Strings and Characters</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/string-fn.html">Built-in Functions</a></li></ol></li><li class="chapter-item expanded "><a href="language/arrays.html">Arrays</a></li><li class="chapter-item expanded "><a href="language/object-maps.html">Object Maps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/json.html">Parse from JSON</a></li><li class="chapter-item expanded "><a href="language/object-maps-oop.html">Special Support for OOP</a></li></ol></li><li class="chapter-item expanded "><a href="language/timestamps.html">Time-Stamps</a></li></ol></li><li class="chapter-item expanded "><a href="language/keywords.html">Keywords</a></li><li class="chapter-item expanded "><a href="language/statements.html">Statements</a></li><li class="chapter-item expanded "><a href="language/variables.html">Variables</a></li><li class="chapter-item expanded "><a href="language/constants.html">Constants</a></li><li class="chapter-item expanded "><a href="language/logic.html">Logic Operators</a></li><li class="chapter-item expanded "><a href="language/if.html">If Statement</a></li><li class="chapter-item expanded "><a href="language/while.html">While Loop</a></li><li class="chapter-item expanded "><a href="language/loop.html">Loop Statement</a></li><li class="chapter-item expanded "><a href="language/for.html">For Loop</a></li><li class="chapter-item expanded "><a href="language/return.html">Return Values</a></li><li class="chapter-item expanded "><a href="language/throw.html">Throw Exception on Error</a></li><li class="chapter-item expanded "><a href="language/functions.html">Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/method.html">Call Method as Function</a></li><li class="chapter-item expanded "><a href="language/overload.html">Overloading</a></li><li class="chapter-item expanded "><a href="language/fn-namespaces.html">Namespaces</a></li><li class="chapter-item expanded "><a href="language/fn-ptr.html">Function Pointers</a></li></ol></li><li class="chapter-item expanded "><a href="language/print-debug.html">Print and Debug</a></li><li class="chapter-item expanded "><a href="language/modules/index.html">Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/modules/export.html">Export Variables, Functions and Sub-Modules</a></li><li class="chapter-item expanded "><a href="language/modules/import.html">Import Modules</a></li><li class="chapter-item expanded "><a href="language/modules/rust.html">Create from Rust</a></li><li class="chapter-item expanded "><a href="language/modules/ast.html">Create from AST</a></li><li class="chapter-item expanded "><a href="language/modules/resolvers.html">Module Resolvers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/modules/imp-resolver.html">Implement a Custom Module Resolver</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="safety/index.html">Safety and Protection</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safety/checked.html">Checked Arithmetic</a></li><li class="chapter-item expanded "><a href="safety/sandbox.html">Sand-Boxing</a></li><li class="chapter-item expanded "><a href="safety/max-string-size.html">Maximum Length of Strings</a></li><li class="chapter-item expanded "><a href="safety/max-array-size.html">Maximum Size of Arrays</a></li><li class="chapter-item expanded "><a href="safety/max-map-size.html">Maximum Size of Object Maps</a></li><li class="chapter-item expanded "><a href="safety/max-operations.html">Maximum Number of Operations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safety/progress.html">Tracking Progress and Force-Termination</a></li></ol></li><li class="chapter-item expanded "><a href="safety/max-modules.html">Maximum Number of Modules</a></li><li class="chapter-item expanded "><a href="safety/max-call-stack.html">Maximum Call Stack Depth</a></li><li class="chapter-item expanded "><a href="safety/max-stmt-depth.html">Maximum Statement Depth</a></li></ol></li><li class="chapter-item expanded "><a href="advanced.html">Advanced Topics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/oop.html">Object-Oriented Programming (OOP)</a></li><li class="chapter-item expanded "><a href="rust/serde.html">Serialization/Deserialization of Dynamic with serde</a></li><li class="chapter-item expanded "><a href="engine/optimize/index.html">Script Optimization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/optimize/optimize-levels.html">Optimization Levels</a></li><li class="chapter-item expanded "><a href="engine/optimize/reoptimize.html">Re-Optimize an AST</a></li><li class="chapter-item expanded "><a href="engine/optimize/eager.html">Eager Function Evaluation</a></li><li class="chapter-item expanded "><a href="engine/optimize/side-effects.html">Side-Effect Considerations</a></li><li class="chapter-item expanded "><a href="engine/optimize/volatility.html">Volatility Considerations</a></li><li class="chapter-item expanded "><a href="engine/optimize/semantics.html">Subtle Semantic Changes</a></li></ol></li><li class="chapter-item expanded "><a href="language/eval.html">Eval Statement</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html">Appendix</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/keywords.html">Keywords</a></li><li class="chapter-item expanded "><a href="appendix/operators.html">Operators</a></li><li class="chapter-item expanded "><a href="appendix/literals.html">Literals</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rhai - Embedded Scripting for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/jonathandturner/rhai" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-rhai" id="what-is-rhai">What is Rhai</a></h1>
<p>Rhai is an embedded scripting language and evaluation engine for Rust that gives a safe and easy way
to add scripting to any application.</p>
<p>This Book is for version 0.17.0 of Rhai.</p>
<p>For the latest development version, see <a href="about//rhai/vnext/vnext/">here</a>.</p>
<h1><a class="header" href="#features" id="features">Features</a></h1>
<h2><a class="header" href="#easy" id="easy">Easy</a></h2>
<ul>
<li>
<p>Easy-to-use language similar to JavaScript+Rust with dynamic typing.</p>
</li>
<li>
<p>Tight integration with native Rust <a href="about//rhai/vnext/language/functions.html">functions</a> and <a href="about//rhai/vnext/rust/custom.html">types</a>, including <a href="about//rhai/vnext/rust/getters-setters.html">getters/setters</a>, <a href="about//rhai/vnext/rust/custom.html">methods</a> and <a href="about//rhai/vnext/rust/indexers.html">indexers</a>.</p>
</li>
<li>
<p>Freely pass Rust variables/constants into a script via an external <a href="about//rhai/vnext/rust/scope.html"><code>Scope</code></a>.</p>
</li>
<li>
<p>Easily <a href="about//rhai/vnext/engine/call-fn.html">call a script-defined function</a> from Rust.</p>
</li>
<li>
<p>Very few additional dependencies (right now only <a href="https://crates.io/crates/num-traits/"><code>num-traits</code></a> to do checked arithmetic operations);
for <a href="about//rhai/vnext/start/features.html"><code>no-std</code></a> builds, a number of additional dependencies are pulled in to provide for functionalities that used to be in <code>std</code>.</p>
</li>
</ul>
<h2><a class="header" href="#fast" id="fast">Fast</a></h2>
<ul>
<li>
<p>Fairly low compile-time overhead.</p>
</li>
<li>
<p>Fairly efficient evaluation (1 million iterations in 0.4 sec on a single core, 2.3 GHz Linux VM).</p>
</li>
<li>
<p>Scripts are <a href="about//rhai/vnext/engine/optimize/index.html">optimized</a> (useful for template-based machine-generated scripts) for repeated evaluations.</p>
</li>
</ul>
<h2><a class="header" href="#dynamic" id="dynamic">Dynamic</a></h2>
<ul>
<li>
<p><a href="about//rhai/vnext/language/overload.html">Function overloading</a>.</p>
</li>
<li>
<p><a href="about//rhai/vnext/rust/operators.html">Operator overloading</a>.</p>
</li>
<li>
<p>Organize code base with dynamically-loadable <a href="about//rhai/vnext/language/modules/index.html">modules</a>.</p>
</li>
<li>
<p>Dynamic dispatch via <a href="about//rhai/vnext/language/fn-ptr.html">function pointers</a>.</p>
</li>
<li>
<p>Some support for <a href="about//rhai/vnext/language/oop.html">object-oriented programming (OOP)</a>.</p>
</li>
<li>
<p>Serialization/deserialization support via <a href="about//rhai/vnext/rust/serde.html"><code>serde</code></a>.</p>
</li>
</ul>
<h2><a class="header" href="#safe" id="safe">Safe</a></h2>
<ul>
<li>Relatively little <code>unsafe</code> code (yes there are some for performance reasons, and most <code>unsafe</code> code is limited to
one single source file, all with names starting with <code>&quot;unsafe_&quot;</code>).</li>
</ul>
<h2><a class="header" href="#rugged" id="rugged">Rugged</a></h2>
<ul>
<li>
<p>Sand-boxed - the scripting <a href="about//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>, if declared immutable, cannot mutate the containing environment unless explicitly permitted (e.g. via a <code>RefCell</code>).</p>
</li>
<li>
<p>Protected against malicious attacks (such as <a href="about//rhai/vnext/safety/max-call-stack.html">stack-overflow</a>, <a href="about//rhai/vnext/safety/max-string-size.html">over-sized data</a>, and <a href="about//rhai/vnext/safety/max-operations.html">runaway scripts</a> etc.) that may come from untrusted third-party user-land scripts.</p>
</li>
<li>
<p>Track script evaluation <a href="about//rhai/vnext/safety/progress.html">progress</a> and manually terminate a script run.</p>
</li>
</ul>
<h2><a class="header" href="#flexible" id="flexible">Flexible</a></h2>
<ul>
<li>
<p>Re-entrant scripting <a href="about//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> can be made <code>Send + Sync</code> (via the <a href="about//rhai/vnext/start/features.html"><code>sync</code></a> feature).</p>
</li>
<li>
<p>Support for <a href="about//rhai/vnext/start/builds/minimal.html">minimal builds</a> by excluding unneeded language <a href="about//rhai/vnext/start/features.html">features</a>.</p>
</li>
<li>
<p>Supports <a href="about/targets.html">most build targets</a> including <code>no-std</code> and <a href="about//rhai/vnext/start/builds/wasm.html">WASM</a>.</p>
</li>
</ul>
<h1><a class="header" href="#supported-targets-and-builds" id="supported-targets-and-builds">Supported Targets and Builds</a></h1>
<p>The following targets and builds are support by Rhai:</p>
<ul>
<li>
<p>All common CPU targets for Windows, Linux and MacOS.</p>
</li>
<li>
<p>WebAssembly (<a href="about//rhai/vnext/start/builds/wasm.html">WASM</a>)</p>
</li>
<li>
<p><a href="about//rhai/vnext/start/features.html"><code>no-std</code></a></p>
</li>
</ul>
<h1><a class="header" href="#what-rhai-isnt" id="what-rhai-isnt">What Rhai Isn’t</a></h1>
<p>Rhai’s purpose is to provide a dynamic layer over Rust code, in the same spirit of <em>zero cost abstractions</em>.
It doesn’t attempt to be a new language. For example:</p>
<ul>
<li>
<p>No classes.  Well, Rust doesn’t either. On the other hand...</p>
</li>
<li>
<p>No traits...  so it is also not Rust. Do your Rusty stuff in Rust.</p>
</li>
<li>
<p>No structures/records - define your types in Rust instead; Rhai can seamlessly work with <em>any Rust type</em>.</p>
<p>There is, however, a built-in <a href="about//rhai/vnext/language/object-maps.html">object map</a> type which is adequate for most uses.
It is possible to simulate <a href="about//rhai/vnext/language/oop.html">object-oriented programming (OOP)</a> by storing <a href="about//rhai/vnext/language/fn-ptr.html">function pointers</a>
in <a href="about//rhai/vnext/language/object-maps.html">object map</a> properties, turning them into <em>methods</em>.</p>
</li>
<li>
<p>No first-class functions - Code your functions in Rust instead, and register them with Rhai.</p>
<p>There is, however, support for simple <a href="about//rhai/vnext/language/fn-ptr.html">function pointers</a> allowing runtime dispatch by function name.</p>
</li>
<li>
<p>No garbage collection - this should be expected, so...</p>
</li>
<li>
<p>No closures - do your closure magic in Rust instead; <a href="about//rhai/vnext/engine/call-fn.html">turn a Rhai scripted function into a Rust closure</a>.</p>
</li>
<li>
<p>No byte-codes/JIT - Rhai has an AST-walking interpreter which will not win any speed races. The purpose of Rhai is not
to be extremely <em>fast</em>, but to make it as easy as possible to integrate with native Rust programs.</p>
</li>
</ul>
<p>Due to this intended usage, Rhai deliberately keeps the language simple and small by omitting advanced language features
such as classes, inheritance, first-class functions, closures, concurrency, byte-codes, JIT etc.</p>
<p>Avoid the temptation to write full-fledge program logic entirely in Rhai - that use case is best fulfilled by
more complete languages such as JavaScript or Lua.</p>
<p>Therefore, in actual practice, it is usually best to expose a Rust API into Rhai for scripts to call.
All your core functionalities should be in Rust.
This is similar to some dynamic languages where most of the core functionalities reside in a C/C++ standard library.</p>
<h1><a class="header" href="#related-resources" id="related-resources">Related Resources</a></h1>
<p>Other online documentation resources for Rhai:</p>
<ul>
<li>
<p><a href="https://crates.io/crates/rhai/"><code>crates.io</code></a> - Rhai crate</p>
</li>
<li>
<p><a href="https://docs.rs/rhai"><code>DOCS.RS</code></a> - Rhai API documentation</p>
</li>
<li>
<p><a href="https://lib.rs/crates/rhai"><code>LIB.RS</code></a> - Rhai library info</p>
</li>
<li>
<p><a href="https://alvinhochun.github.io/rhai-demo">Online Playground</a> - Run scripts directly from editor</p>
</li>
</ul>
<p>Other cool projects to check out:</p>
<ul>
<li>
<p><a href="http://chaiscript.com/">ChaiScript</a> - A strong inspiration for Rhai.  An embedded scripting language for C++ that I helped created many moons ago, now being led by my cousin.</p>
</li>
<li>
<p>Check out the list of <a href="https://github.com/rust-unofficial/awesome-rust#scripting">scripting languages for Rust</a> on <a href="https://github.com/rust-unofficial/awesome-rust">awesome-rust</a></p>
</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This section shows how to install the Rhai crate into a Rust application.</p>
<h1><a class="header" href="#online-playground" id="online-playground">Online Playground</a></h1>
<p>Rhai provides an <a href="https://alvinhochun.github.io/rhai-demo">online playground</a> to try out its language and engine features
without having to install anything.</p>
<p>The playground provides a syntax-highlighting script editor with example snippets.
Scripts can be evaluated directly from the editor.</p>
<h1><a class="header" href="#install-the-rhai-crate" id="install-the-rhai-crate">Install the Rhai Crate</a></h1>
<p>In order to use Rhai in a project, the Rhai crate must first be made a dependency.</p>
<p>The easiest way is to install the Rhai crate from <a href="https:/crates.io/crates/rhai/"><code>crates.io</code></a>,
starting by looking up the latest version and adding this line under <code>dependencies</code> in the project’s <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rhai = &quot;0.17.0&quot;    # assuming 0.17.0 is the latest version
</code></pre>
<p>Or to automatically use the latest released crate version on <a href="https:/crates.io/crates/rhai/"><code>crates.io</code></a>:</p>
<pre><code class="language-toml">[dependencies]
rhai = &quot;*&quot;
</code></pre>
<p>Crate versions are released on <a href="https:/crates.io/crates/rhai/"><code>crates.io</code></a> infrequently,
so to track the latest features, enhancements and bug fixes, pull directly from GitHub:</p>
<pre><code class="language-toml">[dependencies]
rhai = { git = &quot;https://github.com/jonathandturner/rhai&quot; }
</code></pre>
<h1><a class="header" href="#optional-features" id="optional-features">Optional Features</a></h1>
<p>By default, Rhai includes all the standard functionalities in a small, tight package.</p>
<p>Most features are here to opt-<strong>out</strong> of certain functionalities that are not needed.
Notice that this deviates from Rust norm where features are <em>additive</em>.</p>
<p>Excluding unneeded functionalities can result in smaller, faster builds as well as
more control over what a script can (or cannot) do.</p>
<table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>unchecked</code></td><td>Disable arithmetic checking (such as over-flows and division by zero), call stack depth limit, operations count limit and modules loading limit.<br/>Beware that a bad script may panic the entire system!</td></tr>
<tr><td><code>sync</code></td><td>Restrict all values types to those that are <code>Send + Sync</code>. Under this feature, all Rhai types, including <a href="start//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>, <a href="start//rhai/vnext/rust/scope.html"><code>Scope</code></a> and <a href="start//rhai/vnext/engine/compile.html"><code>AST</code></a>, are all <code>Send + Sync</code>.</td></tr>
<tr><td><code>no_optimize</code></td><td>Disable <a href="start//rhai/vnext/engine/optimize/index.html">script optimization</a>.</td></tr>
<tr><td><code>no_float</code></td><td>Disable floating-point numbers and math.</td></tr>
<tr><td><code>only_i32</code></td><td>Set the system integer type to <code>i32</code> and disable all other integer types. <code>INT</code> is set to <code>i32</code>.</td></tr>
<tr><td><code>only_i64</code></td><td>Set the system integer type to <code>i64</code> and disable all other integer types. <code>INT</code> is set to <code>i64</code>.</td></tr>
<tr><td><code>no_index</code></td><td>Disable <a href="start//rhai/vnext/language/arrays.html">arrays</a> and indexing features.</td></tr>
<tr><td><code>no_object</code></td><td>Disable support for <a href="start//rhai/vnext/rust/custom.html">custom types</a> and <a href="start//rhai/vnext/language/object-maps.html">object maps</a>.</td></tr>
<tr><td><code>no_function</code></td><td>Disable script-defined <a href="start//rhai/vnext/language/functions.html">functions</a>.</td></tr>
<tr><td><code>no_module</code></td><td>Disable loading external <a href="start//rhai/vnext/language/modules/index.html">modules</a>.</td></tr>
<tr><td><code>no_std</code></td><td>Build for <code>no-std</code>. Notice that additional dependencies will be pulled in to replace <code>std</code> features.</td></tr>
<tr><td><code>serde</code></td><td>Enable serialization/deserialization via <a href="start//rhai/vnext/rust/serde.html"><code>serde</code></a>. Notice that the <a href="https://crates.io/crates/serde"><code>serde</code></a> crate will be pulled in together with its dependencies.</td></tr>
<tr><td><code>internals</code></td><td>Expose internal data structures (e.g. <a href="start//rhai/vnext/engine/compile.html"><code>AST</code></a> nodes). Beware that Rhai internals are volatile and may change from version to version.</td></tr>
</tbody></table>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>The <code>Cargo.toml</code> configuration below turns on these six features:</p>
<ul>
<li><code>sync</code> (everything <code>Send + Sync</code>)</li>
<li><code>unchecked</code> (disable all checking - should not be used with untrusted user scripts)</li>
<li><code>only_i32</code> (only 32-bit signed integers)</li>
<li><code>no_float</code> (no floating point numbers)</li>
<li><code>no_module</code> (no loading external <a href="start//rhai/vnext/language/modules/index.html">modules</a>)</li>
<li><code>no_function</code> (no defining <a href="start//rhai/vnext/language/functions.html">functions</a>)</li>
</ul>
<pre><code class="language-toml">[dependencies]
rhai = { version = &quot;0.17.0&quot;, features = [ &quot;sync&quot;, &quot;unchecked&quot;, &quot;only_i32&quot;, &quot;no_float&quot;, &quot;no_module&quot;, &quot;no_function&quot; ] }
</code></pre>
<p>The resulting scripting engine supports only the <code>i32</code> integer numeral type (and no others like <code>u32</code>, <code>i16</code> or <code>i64</code>),
no floating-point, is <code>Send + Sync</code> (so it can be safely used across threads), does not support defining <a href="start//rhai/vnext/language/functions.html">functions</a>
nor loading external <a href="start//rhai/vnext/language/modules/index.html">modules</a>.</p>
<p>This configuration is perfect for an expression parser in a 32-bit embedded system without floating-point hardware.</p>
<h1><a class="header" href="#special-builds" id="special-builds">Special Builds</a></h1>
<p>It is possible to mix-and-match various <a href="start/builds//rhai/vnext/start/features.html">features</a> of the Rhai crate to make
specialized builds with specific characteristics and behaviors.</p>
<h1><a class="header" href="#performance-build" id="performance-build">Performance Build</a></h1>
<h2><a class="header" href="#use-only-one-integer-type" id="use-only-one-integer-type">Use Only One Integer Type</a></h2>
<p>Some features are for performance.  For example, using <a href="start/builds//rhai/vnext/start/features.html"><code>only_i32</code></a> or <a href="start/builds//rhai/vnext/start/features.html"><code>only_i64</code></a> disables all other integer types (such as <code>u16</code>).</p>
<p>If only a single integer type is needed in scripts - most of the time this is the case - it is best to avoid registering
lots of functions related to other integer types that will never be used.  As a result, <a href="start/builds//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> creation will be faster
because fewer functions need to be loaded.</p>
<h2><a class="header" href="#use-only-32-bit-numbers" id="use-only-32-bit-numbers">Use Only 32-Bit Numbers</a></h2>
<p>If only 32-bit integers are needed - again, most of the time this is the case - using <a href="start/builds//rhai/vnext/start/features.html"><code>only_i32</code></a> disables also <code>i64</code>.</p>
<p>On 64-bit targets this may not gain much, but on some 32-bit targets this improves performance due to 64-bit arithmetic
requiring more CPU cycles to complete.</p>
<h2><a class="header" href="#minimize-size-of-a-hrefstartbuildsrhaivnextlanguagedynamichtmldynamica" id="minimize-size-of-a-hrefstartbuildsrhaivnextlanguagedynamichtmldynamica">Minimize Size of <a href="start/builds//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a></a></h2>
<p>Turning on <a href="start/builds//rhai/vnext/start/features.html"><code>no_float</code></a>, and <a href="start/builds//rhai/vnext/start/features.html"><code>only_i32</code></a> makes the key <a href="start/builds//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> data type only 8 bytes small on 32-bit targets
while normally it can be up to 16 bytes (e.g. on x86/x64 CPU’s) in order to hold an <code>i64</code> or <code>f64</code>.</p>
<p>Making <a href="start/builds//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> small helps performance due to better cache efficiency.</p>
<h1><a class="header" href="#minimal-build" id="minimal-build">Minimal Build</a></h1>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>In order to compile a <em>minimal</em> build - i.e. a build optimized for size - perhaps for <code>no-std</code> embedded targets or for
compiling to <a href="start/builds//rhai/vnext/start/builds/wasm.html">WASM</a>, it is essential that the correct linker flags are used in <code>cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release]
lto = &quot;fat&quot;         # turn on Link-Time Optimizations
codegen-units = 1   # trade compile time with maximum optimization
opt-level = &quot;z&quot;     # optimize for size
</code></pre>
<h2><a class="header" href="#use-i32-only" id="use-i32-only">Use <code>i32</code> Only</a></h2>
<p>For embedded systems that must optimize for code size, the architecture is commonly 32-bit.
Use <a href="start/builds//rhai/vnext/start/features.html"><code>only_i32</code></a> to prune away large sections of code implementing functions for other numeric types
(including <code>i64</code>).</p>
<p>If, for some reason, 64-bit long integers must be supported, use <a href="start/builds//rhai/vnext/start/features.html"><code>only_i64</code></a> instead of <a href="start/builds//rhai/vnext/start/features.html"><code>only_i32</code></a>.</p>
<h2><a class="header" href="#opt-out-of-features" id="opt-out-of-features">Opt-Out of Features</a></h2>
<p>Opt out of as many features as possible, if they are not needed, to reduce code size because, remember, by default
all code is compiled in as what a script requires cannot be predicted. If a language feature is not needed,
omitting them via special features is a prudent strategy to optimize the build for size.</p>
<p>Omitting arrays (<a href="start/builds//rhai/vnext/start/features.html"><code>no_index</code></a>) yields the most code-size savings, followed by floating-point support
(<a href="start/builds//rhai/vnext/start/features.html"><code>no_float</code></a>), checked arithmetic/script resource limits (<a href="start/builds//rhai/vnext/start/features.html"><code>unchecked</code></a>) and finally object maps and custom types (<a href="start/builds//rhai/vnext/start/features.html"><code>no_object</code></a>).</p>
<p>Where the usage scenario does not call for loading externally-defined modules, use <a href="start/builds//rhai/vnext/start/features.html"><code>no_module</code></a> to save some bytes.
Disable script-defined functions (<a href="start/builds//rhai/vnext/start/features.html"><code>no_function</code></a>) when the feature is not needed.
Both of these have little code size savings.</p>
<h2><a class="header" href="#use-a-raw-a-hrefstartbuildsrhaivnextenginehello-worldhtmlenginea" id="use-a-raw-a-hrefstartbuildsrhaivnextenginehello-worldhtmlenginea">Use a Raw <a href="start/builds//rhai/vnext/engine/hello-world.html"><code>Engine</code></a></a></h2>
<p><a href="start/builds//rhai/vnext/engine/raw.html"><code>Engine::new_raw</code></a> creates a <em>raw</em> engine.
A <em>raw</em> engine supports, out of the box, only a very <a href="start/builds//rhai/vnext/engine/raw.html#built-in-operators">restricted set</a>
of basic arithmetic and logical operators.</p>
<p>Selectively include other necessary functionalities by loading specific <a href="start/builds//rhai/vnext/rust/packages/index.html">packages</a> to minimize the footprint.</p>
<p>Packages are sharable (even across threads via the <a href="start/builds//rhai/vnext/start/features.html"><code>sync</code></a> feature), so they only have to be created once.</p>
<h1><a class="header" href="#no-std-build" id="no-std-build"><code>no-std</code> Build</a></h1>
<p>The feature <a href="start/builds//rhai/vnext/start/features.html"><code>no_std</code></a> automatically converts the scripting engine into a <code>no-std</code> build.</p>
<p>Usually, a <code>no-std</code> build goes hand-in-hand with <a href="start/builds//rhai/vnext/start/builds/minimal.html">minimal builds</a> because typical embedded
hardware (the primary target for <code>no-std</code>) has limited storage.</p>
<h1><a class="header" href="#building-to-webassembly-wasm" id="building-to-webassembly-wasm">Building to WebAssembly (WASM)</a></h1>
<p>It is possible to use Rhai when compiling to WebAssembly (WASM). This yields a scripting engine (and language)
that can be run in a standard web browser.</p>
<p>Why you would want to is another matter... as there is already a nice, fast, complete scripting language
for the the common WASM environment (i.e. a browser) - and it is called JavaScript.</p>
<p>But anyhow, do it because you <em>can</em>!</p>
<p>When building for WASM, certain features will not be available, such as the script file API’s and loading modules
from external script files.</p>
<h2><a class="header" href="#size" id="size">Size</a></h2>
<p>Also look into <a href="start/builds//rhai/vnext/start/builds/minimal.html">minimal builds</a> to reduce generated WASM size.</p>
<p>As of this version, a typical, full-featured Rhai scripting engine compiles to a single WASM file
less than 200KB gzipped.</p>
<p>When excluding features that are marginal in WASM environment, the gzipped payload can be
further shrunk to 160KB.</p>
<h2><a class="header" href="#speed" id="speed">Speed</a></h2>
<p>In benchmark tests, a WASM build runs scripts roughly 1.7-2.2x slower than a native optimized release build.</p>
<h2><a class="header" href="#common-features" id="common-features">Common Features</a></h2>
<p>Some Rhai functionalities are not necessary in a WASM environment, so the following features
are typically used for a WASM build:</p>
<table><thead><tr><th align="center">Feature</th><th>Description</th></tr></thead><tbody>
<tr><td align="center"><a href="start/builds//rhai/vnext/start/features.html"><code>unchecked</code></a></td><td>When a WASM module panics, it doesn’t crash the entire web app; however this also disables <a href="start/builds//rhai/vnext/safety/max-operations.html">maximum number of operations</a> and <a href="start/builds//rhai/vnext/safety/progress.html">progress</a> tracking so a script can still run indefinitely - the web app must terminate it itself.</td></tr>
<tr><td align="center"><a href="start/builds//rhai/vnext/start/features.html"><code>only_i32</code></a></td><td>JavaScript has only one <code>number</code> type and we’re only supporting <code>wasm32</code> here (so far).</td></tr>
<tr><td align="center"><a href="start/builds//rhai/vnext/start/features.html"><code>no_module</code></a></td><td>A WASM module cannot load modules from the file system, so usually this is not needed, but the savings are minimal; alternatively, a custom <a href="start/builds//rhai/vnext/language/modules/imp-resolver.html">module resolver</a> can be provided that loads other Rhai scripts.</td></tr>
</tbody></table>
<p>The following features are typically <em>not</em> used because they don’t make sense in a WASM build:</p>
<table><thead><tr><th align="center">Feature</th><th>Why unnecessary</th></tr></thead><tbody>
<tr><td align="center"><a href="start/builds//rhai/vnext/start/features.html"><code>sync</code></a></td><td>WASM is single-threaded.</td></tr>
<tr><td align="center"><a href="start/builds//rhai/vnext/start/features.html"><code>no_std</code></a></td><td><code>std</code> lib works fine with WASM.</td></tr>
<tr><td align="center"><a href="start/builds//rhai/vnext/start/features.html"><code>internals</code></a></td><td>WASM usually doesn’t need to access Rhai internal data structures.</td></tr>
</tbody></table>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>Rhai comes with a number of examples showing how to integrate the scripting <a href="start/examples//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> within
a Rust application, as well as a number of sample scripts that showcase different Rhai language features.</p>
<h1><a class="header" href="#rust-examples" id="rust-examples">Rust Examples</a></h1>
<p>A number of examples can be found in the <code>examples</code> folder:</p>
<table><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/arrays_and_structs.rs"><code>arrays_and_structs</code></a></td><td>Shows how to register a custom Rust type and using <a href="start/examples//rhai/vnext/language/arrays.html">arrays</a> on it.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/custom_types_and_methods.rs"><code>custom_types_and_methods</code></a></td><td>Shows how to register a custom Rust type and methods for it.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/hello.rs"><code>hello</code></a></td><td>Simple example that evaluates an expression and prints the result.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/no_std.rs"><code>no_std</code></a></td><td>Example to test out <code>no-std</code> builds.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/reuse_scope.rs"><code>reuse_scope</code></a></td><td>Evaluates two pieces of code in separate runs, but using a common <a href="start/examples//rhai/vnext/rust/scope.html"><code>Scope</code></a>.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/rhai_runner.rs"><code>rhai_runner</code></a></td><td>Runs each filename passed to it as a Rhai script.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/simple_fn.rs"><code>simple_fn</code></a></td><td>Shows how to register a simple function.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/strings.rs"><code>strings</code></a></td><td>Shows different ways to register functions taking string arguments.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/examples/repl.rs"><code>repl</code></a></td><td>A simple REPL, interactively evaluate statements from stdin.</td></tr>
</tbody></table>
<p>The <code>repl</code> example is a particularly good one as it allows one to interactively try out Rhai’s
language features in a standard REPL (<strong>R</strong>ead-<strong>E</strong>val-<strong>P</strong>rint <strong>L</strong>oop).</p>
<h2><a class="header" href="#running-examples" id="running-examples">Running Examples</a></h2>
<p>Examples can be run with the following command:</p>
<pre><code class="language-bash">cargo run --example {example_name}
</code></pre>
<h1><a class="header" href="#example-scripts" id="example-scripts">Example Scripts</a></h1>
<h2><a class="header" href="#language-feature-scripts" id="language-feature-scripts">Language Feature Scripts</a></h2>
<p>There are also a number of examples scripts that showcase Rhai’s features, all in the <code>scripts</code> folder:</p>
<table><thead><tr><th>Script</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/array.rhai"><code>array.rhai</code></a></td><td><a href="start/examples//rhai/vnext/language/arrays.html">Arrays</a></td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/assignment.rhai"><code>assignment.rhai</code></a></td><td>Variable declarations</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/comments.rhai"><code>comments.rhai</code></a></td><td>Just comments</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/for1.rhai"><code>for1.rhai</code></a></td><td><a href="start/examples/scripts.html#for-loop"><code>for</code></a> loops</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/for2.rhai"><code>for2.rhai</code></a></td><td><a href="start/examples/scripts.html#for-loop"><code>for</code></a> loops on <a href="start/examples//rhai/vnext/language/arrays.html">arrays</a></td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/function_decl1.rhai"><code>function_decl1.rhai</code></a></td><td>A <a href="start/examples//rhai/vnext/language/functions.html">function</a> without parameters</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/function_decl2.rhai"><code>function_decl2.rhai</code></a></td><td>A <a href="start/examples//rhai/vnext/language/functions.html">function</a> with two parameters</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/function_decl3.rhai"><code>function_decl3.rhai</code></a></td><td>A <a href="start/examples//rhai/vnext/language/functions.html">function</a> with many parameters</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/if1.rhai"><code>if1.rhai</code></a></td><td><a href="start/examples/scripts.html#if-statement"><code>if</code></a> example</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/loop.rhai"><code>loop.rhai</code></a></td><td>Count-down <a href="start/examples/scripts.html#infinite-loop"><code>loop</code></a> in Rhai, emulating a <code>do</code> .. <code>while</code> loop</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/oop.rhai"><code>oop.rhai</code></a></td><td>Simulate <a href="start/examples//rhai/vnext/language/oop.html">object-oriented programming (OOP)</a></td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/op1.rhai"><code>op1.rhai</code></a></td><td>Just simple addition</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/op2.rhai"><code>op2.rhai</code></a></td><td>Simple addition and multiplication</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/op3.rhai"><code>op3.rhai</code></a></td><td>Change evaluation order with parenthesis</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/string.rhai"><code>string.rhai</code></a></td><td><a href="start/examples//rhai/vnext/language/strings-chars.html">String</a> operations</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/strings_map.rhai"><code>strings_map.rhai</code></a></td><td><a href="start/examples//rhai/vnext/language/strings-chars.html">String</a> and <a href="start/examples//rhai/vnext/language/object-maps.html">object map</a> operations</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/while.rhai"><code>while.rhai</code></a></td><td><a href="start/examples/scripts.html#while-loop"><code>while</code></a> loop</td></tr>
</tbody></table>
<h2><a class="header" href="#benchmark-scripts" id="benchmark-scripts">Benchmark Scripts</a></h2>
<p>The following scripts are for benchmarking the speed of Rhai:</p>
<table><thead><tr><th>Scripts</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/speed_test.rhai"><code>speed_test.rhai</code></a></td><td>A simple program to measure the speed of Rhai’s interpreter (1 million iterations).</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/primes.rhai"><code>primes.rhai</code></a></td><td>Use Sieve of Eratosthenes to find all primes smaller than a limit.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/fibonacci.rhai"><code>fibonacci.rhai</code></a></td><td>Calculate the n-th Fibonacci number using a really dumb algorithm.</td></tr>
<tr><td><a href="https://github.com/jonathandturner/rhai/tree/master/scripts/mat_mul.rhai"><code>mat_mul.rhai</code></a></td><td>Matrix multiplication test to measure the speed of multi-dimensional array access.</td></tr>
</tbody></table>
<h2><a class="header" href="#running-example-scripts" id="running-example-scripts">Running Example Scripts</a></h2>
<p>To run the scripts, either make a tiny program or use of the <code>rhai_runner</code> example:</p>
<pre><code class="language-bash">cargo run --example rhai_runner scripts/any_script.rhai
</code></pre>
<h1><a class="header" href="#using-the-engine" id="using-the-engine">Using the Engine</a></h1>
<p>Rhai’s interpreter resides in the <a href="engine//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> type under the master <code>rhai</code> namespace.</p>
<p>This section shows how to set up, configure and use this scripting engine.</p>
<h1><a class="header" href="#hello-world-in-rhai" id="hello-world-in-rhai">Hello World in Rhai</a></h1>
<p>To get going with Rhai is as simple as creating an instance of the scripting engine <code>rhai::Engine</code> via
<code>Engine::new</code>, then calling the <code>eval</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">use rhai::{Engine, EvalAltResult};

fn main() -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt;
{
    let engine = Engine::new();

    let result = engine.eval::&lt;i64&gt;(&quot;40 + 2&quot;)?;
    //                      ^^^^^^^ cast the result to an 'i64', this is required

    println!(&quot;Answer: {}&quot;, result);             // prints 42

    Ok(())
}
</code></pre></pre>
<p><code>rhai::EvalAltResult</code> is a Rust <code>enum</code> containing all errors encountered during the parsing or evaluation process.</p>
<h2><a class="header" href="#evaluate-a-script" id="evaluate-a-script">Evaluate a Script</a></h2>
<p>The type parameter is used to specify the type of the return value, which <em>must</em> match the actual type or an error is returned.
Rhai is very strict here.</p>
<p>Use <a href="engine//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> for uncertain return types.</p>
<p>There are two ways to specify the return type - <em>turbofish</em> notation, or type inference.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let result = engine.eval::&lt;i64&gt;(&quot;40 + 2&quot;)?;     // return type is i64, specified using 'turbofish' notation

let result: i64 = engine.eval(&quot;40 + 2&quot;)?;       // return type is inferred to be i64

result.is::&lt;i64&gt;() == true;

let result: Dynamic = engine.eval(&quot;boo()&quot;)?;    // use 'Dynamic' if you're not sure what type it'll be!

let result = engine.eval::&lt;String&gt;(&quot;40 + 2&quot;)?;  // returns an error because the actual return type is i64, not String
<span class="boring">}
</span></code></pre></pre>
<p>Evaluate a script file directly:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let result = engine.eval_file::&lt;i64&gt;(&quot;hello_world.rhai&quot;.into())?;   // 'eval_file' takes a 'PathBuf'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#compile-a-script-to-ast" id="compile-a-script-to-ast">Compile a Script (to AST)</a></h1>
<p>To repeatedly evaluate a script, <em>compile</em> it first into an <code>AST</code> (abstract syntax tree) form:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Compile to an AST and store it for later evaluations
let ast = engine.compile(&quot;40 + 2&quot;)?;

for _ in 0..42 {
    let result: i64 = engine.eval_ast(&amp;ast)?;

    println!(&quot;Answer #{}: {}&quot;, i, result);      // prints 42
}
<span class="boring">}
</span></code></pre></pre>
<p>Compiling a script file is also supported (not available under <a href="engine//rhai/vnext/start/features.html"><code>no_std</code></a> or in <a href="engine//rhai/vnext/start/builds/wasm.html">WASM</a> builds):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let ast = engine.compile_file(&quot;hello_world.rhai&quot;.into())?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#calling-rhai-functions-from-rust" id="calling-rhai-functions-from-rust">Calling Rhai Functions from Rust</a></h1>
<p>Rhai also allows working <em>backwards</em> from the other direction - i.e. calling a Rhai-scripted function
from Rust via <code>Engine::call_fn</code>.</p>
<p>Functions declared with <code>private</code> are hidden and cannot be called from Rust (see also <a href="engine//rhai/vnext/language/modules/index.html">modules</a>).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Define functions in a script.
let ast = engine.compile(true,
    r#&quot;
        // a function with two parameters: string and i64
        fn hello(x, y) {
            x.len + y
        }

        // functions can be overloaded: this one takes only one parameter
        fn hello(x) {
            x * 2
        }

        // this one takes no parameters
        fn hello() {
            42
        }

        // this one is private and cannot be called by 'call_fn'
        private hidden() {
            throw &quot;you shouldn't see me!&quot;;
        }
    &quot;#)?;

// A custom scope can also contain any variables/constants available to the functions
let mut scope = Scope::new();

// Evaluate a function defined in the script, passing arguments into the script as a tuple.
// Beware, arguments must be of the correct types because Rhai does not have built-in type conversions.
// If arguments of the wrong types are passed, the Engine will not find the function.

let result: i64 = engine.call_fn(&amp;mut scope, &amp;ast, &quot;hello&quot;, ( String::from(&quot;abc&quot;), 123_i64 ) )?;
//                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//                                                          put arguments in a tuple

let result: i64 = engine.call_fn(&amp;mut scope, &amp;ast, &quot;hello&quot;, (123_i64,) )?;
//                                                          ^^^^^^^^^^ tuple of one

let result: i64 = engine.call_fn(&amp;mut scope, &amp;ast, &quot;hello&quot;, () )?;
//                                                          ^^ unit = tuple of zero

// The following call will return a function-not-found error because
// 'hidden' is declared with 'private'.
let result: () = engine.call_fn(&amp;mut scope, &amp;ast, &quot;hidden&quot;, ())?;
<span class="boring">}
</span></code></pre></pre>
<p>For more control, construct all arguments as <code>Dynamic</code> values and use <code>Engine::call_fn_dynamic</code>, passing it
anything that implements <code>IntoIterator&lt;Item = Dynamic&gt;</code> (such as a simple <code>Vec&lt;Dynamic&gt;</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let result: Dynamic = engine.call_fn_dynamic(&amp;mut scope, &amp;ast, &quot;hello&quot;,
                            vec![ String::from(&quot;abc&quot;).into(), 123_i64.into() ])?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#create-a-rust-anonymous-function-from-a-rhai-function" id="create-a-rust-anonymous-function-from-a-rhai-function">Create a Rust Anonymous Function from a Rhai Function</a></h1>
<p>It is possible to further encapsulate a script in Rust such that it becomes a normal Rust function.</p>
<p>Such an <em>anonymous function</em> is basically a boxed closure, very useful as call-back functions.</p>
<p>Creating them is accomplished via the <code>Func</code> trait which contains <code>create_from_script</code>
(as well as its companion method <code>create_from_ast</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Func};                       // use 'Func' for 'create_from_script'

let engine = Engine::new();                     // create a new 'Engine' just for this

let script = &quot;fn calc(x, y) { x + y.len &lt; 42 }&quot;;

// Func takes two type parameters:
//   1) a tuple made up of the types of the script function's parameters
//   2) the return type of the script function
//
// 'func' will have type Box&lt;dyn Fn(i64, String) -&gt; Result&lt;bool, Box&lt;EvalAltResult&gt;&gt;&gt; and is callable!
let func = Func::&lt;(i64, String), bool&gt;::create_from_script(
//                ^^^^^^^^^^^^^ function parameter types in tuple

                engine,                         // the 'Engine' is consumed into the closure
                script,                         // the script, notice number of parameters must match
                &quot;calc&quot;                          // the entry-point function name
)?;

func(123, &quot;hello&quot;.to_string())? == false;       // call the anonymous function

schedule_callback(func);                        // pass it as a callback to another function

// Although there is nothing you can't do by manually writing out the closure yourself...
let engine = Engine::new();
let ast = engine.compile(script)?;
schedule_callback(Box::new(move |x: i64, y: String| -&gt; Result&lt;bool, Box&lt;EvalAltResult&gt;&gt; {
    engine.call_fn(&amp;mut Scope::new(), &amp;ast, &quot;calc&quot;, (x, y))
}));
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#evaluate-expressions-only" id="evaluate-expressions-only">Evaluate Expressions Only</a></h1>
<p>Sometimes a use case does not require a full-blown scripting <em>language</em>, but only needs to evaluate <em>expressions</em>.</p>
<p>In these cases, use the <code>Engine::compile_expression</code> and <code>Engine::eval_expression</code> methods or their <code>_with_scope</code> variants.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let result = engine.eval_expression::&lt;i64&gt;(&quot;2 + (10 + 10) * 2&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p>When evaluating <em>expressions</em>, no full-blown statement (e.g. <code>if</code>, <code>while</code>, <code>for</code>) - not even variable assignment -
is supported and will be considered parse errors when encountered.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// The following are all syntax errors because the script is not an expression.

engine.eval_expression::&lt;()&gt;(&quot;x = 42&quot;)?;

let ast = engine.compile_expression(&quot;let x = 42&quot;)?;

let result = engine.eval_expression_with_scope::&lt;i64&gt;(&amp;mut scope, &quot;if x { 42 } else { 123 }&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#raw-engine" id="raw-engine">Raw <code>Engine</code></a></h1>
<p><code>Engine::new</code> creates a scripting <a href="engine//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> with common functionalities (e.g. printing to the console via <code>print</code>).</p>
<p>In many controlled embedded environments, however, these may not be needed and unnecessarily occupy
program code storage space.</p>
<p>Use <code>Engine::new_raw</code> to create a <em>raw</em> <code>Engine</code>, in which only a minimal set of
basic arithmetic and logical operators are supported.</p>
<h2><a class="header" href="#built-in-operators" id="built-in-operators">Built-in Operators</a></h2>
<table><thead><tr><th>Operators</th><th>Assignment operators</th><th>Supported for types (see <a href="engine//rhai/vnext/language/values-and-types.html">standard types</a>)</th></tr></thead><tbody>
<tr><td><code>+</code>,</td><td><code>+=</code></td><td><code>INT</code>, <code>FLOAT</code> (if not <a href="engine//rhai/vnext/start/features.html"><code>no_float</code></a>), <code>ImmutableString</code></td></tr>
<tr><td><code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>~</code>,</td><td><code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>~=</code></td><td><code>INT</code>, <code>FLOAT</code> (if not <a href="engine//rhai/vnext/start/features.html"><code>no_float</code></a>)</td></tr>
<tr><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>^</code>,</td><td><code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>^=</code></td><td><code>INT</code></td></tr>
<tr><td><code>&amp;</code>, `</td><td>`,</td><td><code>&amp;=</code>, `</td></tr>
<tr><td><code>&amp;&amp;</code>, `</td><td></td><td>`</td></tr>
<tr><td><code>==</code>, <code>!=</code></td><td></td><td><code>INT</code>, <code>FLOAT</code> (if not <a href="engine//rhai/vnext/start/features.html"><code>no_float</code></a>), <code>bool</code>, <code>char</code>, <code>()</code>, <code>ImmutableString</code></td></tr>
<tr><td><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></td><td></td><td><code>INT</code>, <code>FLOAT</code> (if not <a href="engine//rhai/vnext/start/features.html"><code>no_float</code></a>), <code>char</code>, <code>()</code>, <code>ImmutableString</code></td></tr>
</tbody></table>
<h1><a class="header" href="#extend-rhai-with-rust" id="extend-rhai-with-rust">Extend Rhai with Rust</a></h1>
<p>Most features and functionalities required by a Rhai script should actually be coded in Rust,
which leverages the superior native run-time speed.</p>
<p>This section discusses how to extend Rhai with functionalities written in Rust.</p>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<p>A number of traits, under the <code>rhai::</code> module namespace, provide additional functionalities.</p>
<table><thead><tr><th>Trait</th><th>Description</th><th>Methods</th></tr></thead><tbody>
<tr><td><code>RegisterFn</code></td><td>Trait for registering functions</td><td><code>register_fn</code></td></tr>
<tr><td><code>RegisterResultFn</code></td><td>Trait for registering fallible functions returning <code>Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code></td><td><code>register_result_fn</code></td></tr>
<tr><td><code>Func</code></td><td>Trait for creating anonymous functions from script</td><td><code>create_from_ast</code>, <code>create_from_script</code></td></tr>
<tr><td><code>ModuleResolver</code></td><td>Trait implemented by module resolution services</td><td><code>resolve</code></td></tr>
</tbody></table>
<h1><a class="header" href="#register-a-rust-function" id="register-a-rust-function">Register a Rust Function</a></h1>
<p>Rhai’s scripting engine is very lightweight.  It gets most of its abilities from functions.</p>
<p>To call these functions, they need to be <em>registered</em> with the <a href="rust//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> using <code>Engine::register_fn</code>
(in the <code>RegisterFn</code> trait) and <code>Engine::register_result_fn</code> (in the <code>RegisterResultFn</code> trait,
see <a href="rust//rhai/vnext/rust/fallible.html">fallible functions</a>).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Dynamic, Engine, EvalAltResult, ImmutableString};
use rhai::RegisterFn;                           // use 'RegisterFn' trait for 'register_fn'
use rhai::RegisterResultFn;                     // use 'RegisterResultFn' trait for 'register_result_fn'

// Normal function that returns a standard type
// Remember to use 'ImmutableString' and not 'String'
fn add_len(x: i64, s: ImmutableString) -&gt; i64 {
    x + s.len()
}
// Alternatively, '&amp;str' maps directly to 'ImmutableString'
fn add_len_str(x: i64, s: &amp;str) -&gt; i64 {
    x + s.len()
}

// Function that returns a 'Dynamic' value - must return a 'Result'
fn get_any_value() -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt; {
    Ok((42_i64).into())                         // standard types can use 'into()'
}

let mut engine = Engine::new();

engine.register_fn(&quot;add&quot;, add_len);
engine.register_fn(&quot;add_str&quot;, add_len_str);

let result = engine.eval::&lt;i64&gt;(r#&quot;add(40, &quot;xx&quot;)&quot;#)?;

println!(&quot;Answer: {}&quot;, result);             // prints 42

let result = engine.eval::&lt;i64&gt;(r#&quot;add_str(40, &quot;xx&quot;)&quot;#)?;

println!(&quot;Answer: {}&quot;, result);             // prints 42

// Functions that return Dynamic values must use register_result_fn()
engine.register_result_fn(&quot;get_any_value&quot;, get_any_value);

let result = engine.eval::&lt;i64&gt;(&quot;get_any_value()&quot;)?;

println!(&quot;Answer: {}&quot;, result);             // prints 42
<span class="boring">}
</span></code></pre></pre>
<p>To create a <a href="rust//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> value, use the <code>Dynamic::from</code> method.
<a href="rust//rhai/vnext/language/values-and-types.html">Standard types</a> in Rhai can also use <code>into()</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::Dynamic;

let x = (42_i64).into();                        // 'into()' works for standard types

let y = Dynamic::from(&quot;hello!&quot;.to_string());    // remember &amp;str is not supported by Rhai
<span class="boring">}
</span></code></pre></pre>
<p>Functions registered with the <a href="rust//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> can be <em>overloaded</em> as long as the <em>signature</em> is unique,
i.e. different functions can have the same name as long as their parameters are of different types
and/or different number.</p>
<p>New definitions <em>overwrite</em> previous definitions of the same name and same number/types of parameters.</p>
<h1><a class="header" href="#string-parameters-in-rust-functions" id="string-parameters-in-rust-functions"><code>String</code> Parameters in Rust Functions</a></h1>
<p>Rust functions accepting parameters of <code>String</code> should use <code>&amp;str</code> instead because it maps directly to [<code>ImmutableString</code>]
which is the type that Rhai uses to represent <a href="rust//rhai/vnext/language/strings-chars.html">strings</a> internally.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn get_len1(s: String) -&gt; i64 { s.len() as i64 }            // &lt;- Rhai will not find this function
fn get_len2(s: &amp;str) -&gt; i64 { s.len() as i64 }              // &lt;- Rhai finds this function fine
fn get_len3(s: ImmutableString) -&gt; i64 { s.len() as i64 }   // &lt;- the above is equivalent to this

engine.register_fn(&quot;len1&quot;, get_len1);
engine.register_fn(&quot;len2&quot;, get_len2);
engine.register_fn(&quot;len3&quot;, get_len3);

let len = engine.eval::&lt;i64&gt;(&quot;x.len1()&quot;)?;                  // error: function 'len1 (&amp;str | ImmutableString)' not found
let len = engine.eval::&lt;i64&gt;(&quot;x.len2()&quot;)?;                  // works fine
let len = engine.eval::&lt;i64&gt;(&quot;x.len3()&quot;)?;                  // works fine
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#register-a-generic-rust-function" id="register-a-generic-rust-function">Register a Generic Rust Function</a></h1>
<p>Rust generic functions can be used in Rhai, but separate instances for each concrete type must be registered separately.</p>
<p>This essentially <em>overloads</em> the function with different parameter types as Rhai does not natively support generics
but Rhai does support <em>function overloading</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

use rhai::{Engine, RegisterFn};

fn show_it&lt;T: Display&gt;(x: &amp;mut T) {
    println!(&quot;put up a good show: {}!&quot;, x)
}

let mut engine = Engine::new();

engine.register_fn(&quot;print&quot;, show_it::&lt;i64&gt;);
engine.register_fn(&quot;print&quot;, show_it::&lt;bool&gt;);
engine.register_fn(&quot;print&quot;, show_it::&lt;ImmutableString&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>The above example shows how to register multiple functions
(or, in this case, multiple overloaded versions of the same function)
under the same name.</p>
<h1><a class="header" href="#register-a-fallible-rust-function" id="register-a-fallible-rust-function">Register a Fallible Rust Function</a></h1>
<p>If a function is <em>fallible</em> (i.e. it returns a <code>Result&lt;_, Error&gt;</code>), it can be registered with <code>register_result_fn</code>
(using the <code>RegisterResultFn</code> trait).</p>
<p>The function must return <code>Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, EvalAltResult, Position};
use rhai::RegisterResultFn;                     // use 'RegisterResultFn' trait for 'register_result_fn'

// Function that may fail - the result type must be 'Dynamic'
fn safe_divide(x: i64, y: i64) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt; {
    if y == 0 {
        // Return an error if y is zero
        Err(&quot;Division by zero!&quot;.into())         // short-cut to create Box&lt;EvalAltResult::ErrorRuntime&gt;
    } else {
        Ok((x / y).into())                      // convert result into 'Dynamic'
    }
}

let mut engine = Engine::new();

// Fallible functions that return Result values must use register_result_fn()
engine.register_result_fn(&quot;divide&quot;, safe_divide);

if let Err(error) = engine.eval::&lt;i64&gt;(&quot;divide(40, 0)&quot;) {
    println!(&quot;Error: {:?}&quot;, *error);         // prints ErrorRuntime(&quot;Division by zero detected!&quot;, (1, 1)&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#create-a-boxevalaltresult" id="create-a-boxevalaltresult">Create a <code>Box&lt;EvalAltResult&gt;</code></a></h2>
<p><code>Box&lt;EvalAltResult&gt;</code> implements <code>From&lt;&amp;str&gt;</code> and <code>From&lt;String&gt;</code> etc.
and the error text gets converted into <code>Box&lt;EvalAltResult::ErrorRuntime&gt;</code>.</p>
<p>The error values are <code>Box</code>-ed in order to reduce memory footprint of the error path, which should be hit rarely.</p>
<h1><a class="header" href="#packages" id="packages">Packages</a></h1>
<p>Standard built-in Rhai features are provided in various <em>packages</em> that can be loaded via a call to <code>Engine::load_package</code>.</p>
<p>Packages reside under <code>rhai::packages::*</code> and the trait <code>rhai::packages::Package</code> must be loaded in order for
packages to be used.</p>
<p>Packages typically contain Rust functions that are callable within a Rhai script.
All functions registered in a package is loaded under the <em>global namespace</em> (i.e. they’re available without module qualifiers).</p>
<p>Once a package is created (e.g. via <code>new</code>), it can be <em>shared</em> (via <code>get</code>) among multiple instances of <a href="rust/packages//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>,
even across threads (under <a href="rust/packages//rhai/vnext/start/features.html"><code>sync</code></a>). Therefore, a package only has to be created <em>once</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::Engine;
use rhai::packages::Package         // load the 'Package' trait to use packages
use rhai::packages::CorePackage;    // the 'core' package contains basic functionalities (e.g. arithmetic)

let mut engine = Engine::new_raw(); // create a 'raw' Engine
let package = CorePackage::new();   // create a package - can be shared among multiple `Engine` instances

engine.load_package(package.get()); // load the package manually. 'get' returns a reference to the shared package
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#difference-between-a-package-and-a-module" id="difference-between-a-package-and-a-module">Difference Between a Package and a Module</a></h2>
<p>Packages are actually implemented as <a href="rust/packages//rhai/vnext/language/modules/index.html">modules</a>, so they share a lot of behavior and characteristics.</p>
<p>The main difference is that a package loads under the <em>global</em> namespace, while a module loads under its own
namespace alias specified in an <a href="rust/packages//rhai/vnext/language/modules/import.html"><code>import</code></a> statement (see also <a href="rust/packages//rhai/vnext/language/modules/index.html">modules</a>).</p>
<p>A package is <em>static</em> (i.e. pre-loaded into an <a href="rust/packages//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>), while a module is <em>dynamic</em> (i.e. loaded with
the <code>import</code> statement).</p>
<h1><a class="header" href="#built-in-packages" id="built-in-packages">Built-In Packages</a></h1>
<p><code>Engine::new</code> creates an <a href="rust/packages//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> with the <code>StandardPackage</code> loaded.</p>
<p><code>Engine::new_raw</code> creates an <a href="rust/packages//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> with <em>no</em> package loaded.</p>
<table><thead><tr><th>Package</th><th>Description</th><th align="center">In <code>Core</code></th><th align="center">In <code>Standard</code></th></tr></thead><tbody>
<tr><td><code>ArithmeticPackage</code></td><td>Arithmetic operators (e.g. <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) for numeric types that are not built in (e.g. <code>u16</code>)</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>BasicIteratorPackage</code></td><td>Numeric ranges (e.g. <code>range(1, 10)</code>)</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>LogicPackage</code></td><td>Logical and comparison operators (e.g. <code>==</code>, <code>&gt;</code>) for numeric types that are not built in (e.g. <code>u16</code>)</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>BasicStringPackage</code></td><td>Basic string functions (e.g. <code>print</code>, <code>debug</code>, <code>len</code>) that are not built in</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>BasicTimePackage</code></td><td>Basic time functions (e.g. <a href="rust/packages//rhai/vnext/language/timestamps.html">timestamps</a>)</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>MoreStringPackage</code></td><td>Additional string functions, including converting common types to string</td><td align="center">No</td><td align="center">Yes</td></tr>
<tr><td><code>BasicMathPackage</code></td><td>Basic math functions (e.g. <code>sin</code>, <code>sqrt</code>)</td><td align="center">No</td><td align="center">Yes</td></tr>
<tr><td><code>BasicArrayPackage</code></td><td>Basic <a href="rust/packages//rhai/vnext/language/arrays.html">array</a> functions (not available under <code>no_index</code>)</td><td align="center">No</td><td align="center">Yes</td></tr>
<tr><td><code>BasicMapPackage</code></td><td>Basic <a href="rust/packages//rhai/vnext/language/object-maps.html">object map</a> functions (not available under <code>no_object</code>)</td><td align="center">No</td><td align="center">Yes</td></tr>
<tr><td><code>BasicFnPackage</code></td><td>Basic methods for <a href="rust/packages//rhai/vnext/language/fn-ptr.html">function pointers</a>.</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>EvalPackage</code></td><td>Disable <a href="rust/packages//rhai/vnext/language/eval.html"><code>eval</code></a></td><td align="center">No</td><td align="center">No</td></tr>
<tr><td><code>CorePackage</code></td><td>Basic essentials</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>StandardPackage</code></td><td>Standard library (default for <code>Engine::new</code>)</td><td align="center">No</td><td align="center">Yes</td></tr>
</tbody></table>
<h2><a class="header" href="#load-the-corepackage" id="load-the-corepackage">Load the <code>CorePackage</code></a></h2>
<p>If only minimal functionalities is required, load the <code>CorePackage</code> instead:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::Engine;
use rhai::packages::{Package, CorePackage};

let mut engine = Engine::new_raw();
let package = CorePackage::new();

engine.load_package(package.get());
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#create-a-custom-package" id="create-a-custom-package">Create a Custom Package</a></h1>
<p>Sometimes specific functionalities are needed, so custom packages can be created.</p>
<p>The macro <code>rhai::def_package!</code> is used to create a new custom package.</p>
<h2><a class="header" href="#macro-parameters" id="macro-parameters">Macro Parameters</a></h2>
<p><code>def_package!(root:package_name:description, variable, block)</code></p>
<ul>
<li>
<p><code>root</code> - root namespace, usually <code>&quot;rhai&quot;</code>.</p>
</li>
<li>
<p><code>package_name</code> - name of the package, usually ending in <code>Package</code>.</p>
</li>
<li>
<p><code>description</code> - doc comment for the package.</p>
</li>
<li>
<p><code>variable</code> - a variable name holding a reference to the <a href="rust/packages//rhai/vnext/language/modules/index.html">module</a> that is to form the package.</p>
</li>
<li>
<p><code>block</code> - a code block that initializes the package.</p>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Import necessary types and traits.
use rhai::{
    def_package,
    packages::Package,
    packages::{ArithmeticPackage, BasicArrayPackage, BasicMapPackage, LogicPackage}
};

// Define the package 'MyPackage'.
def_package!(rhai:MyPackage:&quot;My own personal super package&quot;, module, {
    // Aggregate existing packages simply by calling 'init' on each.
    ArithmeticPackage::init(module);
    LogicPackage::init(module);
    BasicArrayPackage::init(module);
    BasicMapPackage::init(module);

    // Register additional Rust functions using the standard 'set_fn_XXX' module API.
    module.set_fn_1(&quot;foo&quot;, |s: ImmutableString| {
        Ok(foo(s.into_owned()))
    });
});
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#override-a-built-in-function" id="override-a-built-in-function">Override a Built-in Function</a></h1>
<p>Any similarly-named function defined in a script overrides any built-in or registered
native Rust function of the same name and number of parameters.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Override the built-in function 'to_int'
fn to_int(num) {
    print(&quot;Ha! Gotcha! &quot; + num);
}

print(to_int(123));     // what happens?
<span class="boring">}
</span></code></pre></pre>
<p>A registered native Rust function, in turn, overrides any built-in function of the
same name, number and types of parameters.</p>
<h1><a class="header" href="#operator-overloading" id="operator-overloading">Operator Overloading</a></h1>
<p>In Rhai, a lot of functionalities are actually implemented as functions, including basic operations
such as arithmetic calculations.</p>
<p>For example, in the expression “<code>a + b</code>“, the <code>+</code> operator is <em>not</em> built in, but calls a function named “<code>+</code>“ instead!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = a + b;
let x = +(a, b);        // &lt;- the above is equivalent to this function call
<span class="boring">}
</span></code></pre></pre>
<p>Similarly, comparison operators including <code>==</code>, <code>!=</code> etc. are all implemented as functions,
with the stark exception of <code>&amp;&amp;</code> and <code>||</code>. Because they <a href="rust//rhai/vnext/language/logic.html#boolean-operators"><em>short-circuit</em></a>,
<code>&amp;&amp;</code> and <code>||</code> are handled specially and <em>not</em> via a function; as a result, overriding them has no effect at all.</p>
<h2><a class="header" href="#overload-operator-via-rust-function" id="overload-operator-via-rust-function">Overload Operator via Rust Function</a></h2>
<p>Operator functions cannot be defined as a script function (because operators syntax are not valid function names).</p>
<p>However, operator functions <em>can</em> be registered to the <a href="rust//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> via the methods
<code>Engine::register_fn</code>, <code>Engine::register_result_fn</code> etc.</p>
<p>When a custom operator function is registered with the same name as an operator, it <em>overrides</em> the built-in version.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, EvalAltResult, RegisterFn};

let mut engine = Engine::new();

fn strange_add(a: i64, b: i64) -&gt; i64 { (a + b) * 42 }

engine.register_fn(&quot;+&quot;, strange_add);               // overload '+' operator for two integers!

let result: i64 = engine.eval(&quot;1 + 0&quot;);             // the overloading version is used

println!(&quot;result: {}&quot;, result);                     // prints 42

let result: f64 = engine.eval(&quot;1.0 + 0.0&quot;);         // '+' operator for two floats not overloaded

println!(&quot;result: {}&quot;, result);                     // prints 1.0

fn mixed_add(a: i64, b: f64) -&gt; f64 { (a as f64) + b }

engine.register_fn(&quot;+&quot;, mixed_add);                 // register '+' operator for an integer and a float

let result: i64 = engine.eval(&quot;1 + 1.0&quot;);           // prints 2.0 (normally an error)
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#considerations" id="considerations">Considerations</a></h2>
<p>Normally, use operator overloading for <a href="rust//rhai/vnext/rust/custom.html">custom types</a> only.</p>
<p>Be very careful when overriding built-in operators because script authors expect standard operators to behave in a
consistent and predictable manner, and will be annoyed if a calculation for ‘<code>+</code>‘ turns into a subtraction, for example.</p>
<p>Operator overloading also impacts script optimization when using <a href="rust//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>.
See the [script-optimization] for more details.</p>
<h1><a class="header" href="#register-a-custom-type-and-its-methods" id="register-a-custom-type-and-its-methods">Register a Custom Type and its Methods</a></h1>
<p>Rhai works seamlessly with <em>any</em> complex Rust type.  The type can be registered with the <code>Engine</code>, as below.</p>
<p>Support for custom types can be turned off via the <a href="rust//rhai/vnext/start/features.html"><code>no_object</code></a> feature.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, EvalAltResult};
use rhai::RegisterFn;

#[derive(Clone)]
struct TestStruct {
    field: i64
}

impl TestStruct {
    fn update(&amp;mut self) {
        self.field += 41;
    }

    fn new() -&gt; Self {
        TestStruct { field: 1 }
    }
}

let mut engine = Engine::new();

engine.register_type::&lt;TestStruct&gt;();

engine.register_fn(&quot;update&quot;, TestStruct::update);
engine.register_fn(&quot;new_ts&quot;, TestStruct::new);

let result = engine.eval::&lt;TestStruct&gt;(&quot;let x = new_ts(); x.update(); x&quot;)?;

println!(&quot;result: {}&quot;, result.field);           // prints 42
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#register-a-custom-type" id="register-a-custom-type">Register a Custom Type</a></h2>
<p>A custom type must implement <code>Clone</code> as this allows the <a href="rust//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> to pass by value.</p>
<p>Notice that the custom type needs to be <em>registered</em> using <code>Engine::register_type</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct TestStruct {
    field: i64
}

impl TestStruct {
    fn update(&amp;mut self) {              // methods take &amp;mut as first parameter
        self.field += 41;
    }

    fn new() -&gt; Self {
        TestStruct { field: 1 }
    }
}

let mut engine = Engine::new();

engine.register_type::&lt;TestStruct&gt;();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#methods-on-custom-type" id="methods-on-custom-type">Methods on Custom Type</a></h2>
<p>To use native custom types, methods and functions in Rhai scripts, simply register them
using one of the <code>Engine::register_XXX</code> API.</p>
<p>Below, the <code>update</code> and <code>new</code> methods are registered using <code>Engine::register_fn</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>engine.register_fn(&quot;update&quot;, TestStruct::update);   // registers 'update(&amp;mut TestStruct)'
engine.register_fn(&quot;new_ts&quot;, TestStruct::new);      // registers 'new()'
<span class="boring">}
</span></code></pre></pre>
<p><em><strong>Note</strong>: Rhai follows the convention that methods of custom types take a <code>&amp;mut</code> first parameter
so that invoking methods can update the types. All other parameters in Rhai are passed by value (i.e. clones).</em></p>
<h2><a class="header" href="#use-the-custom-type-in-scripts" id="use-the-custom-type-in-scripts">Use the Custom Type in Scripts</a></h2>
<p>The custom type is then ready for use in scripts.  Scripts can see the functions and methods registered earlier.
Get the evaluation result back out just as before, this time casting to the custom type:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let result = engine.eval::&lt;TestStruct&gt;(&quot;let x = new_ts(); x.update(); x&quot;)?;

println!(&quot;result: {}&quot;, result.field);               // prints 42
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#method-call-style-vs-function-call-style" id="method-call-style-vs-function-call-style">Method-Call Style vs. Function-Call Style</a></h2>
<p>Any function with a first argument that is a <code>&amp;mut</code> reference can be used
as method calls because internally they are the same thing: methods on a type is
implemented as a functions taking a <code>&amp;mut</code> first argument.
This design is similar to Rust.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo(ts: &amp;mut TestStruct) -&gt; i64 {
    ts.field
}

engine.register_fn(&quot;foo&quot;, foo);                     // register a Rust native function

let result = engine.eval::&lt;i64&gt;(
    &quot;let x = new_ts(); x.foo()&quot;                     // 'foo' can be called like a method on 'x'
)?;

println!(&quot;result: {}&quot;, result);                     // prints 1
<span class="boring">}
</span></code></pre></pre>
<p>Under <a href="rust//rhai/vnext/start/features.html"><code>no_object</code></a>, however, the <em>method</em> style of function calls
(i.e. calling a function as an object-method) is no longer supported.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Below is a syntax error under 'no_object' because 'clear' cannot be called in method style.
let result = engine.eval::&lt;()&gt;(&quot;let x = [1, 2, 3]; x.clear()&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#a-hrefrustrhaivnextlanguagetype-ofhtmltype_ofa" id="a-hrefrustrhaivnextlanguagetype-ofhtmltype_ofa"><a href="rust//rhai/vnext/language/type-of.html"><code>type_of()</code></a></a></h2>
<p><a href="rust//rhai/vnext/language/type-of.html"><code>type_of()</code></a> works fine with custom types and returns the name of the type.</p>
<p>If <code>Engine::register_type_with_name</code> is used to register the custom type
with a special “pretty-print” name, <a href="rust//rhai/vnext/language/type-of.html"><code>type_of()</code></a> will return that name instead.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>engine.register_type::&lt;TestStruct&gt;();
engine.register_fn(&quot;new_ts&quot;, TestStruct::new);
let x = new_ts();
print(x.type_of());                                 // prints &quot;path::to::module::TestStruct&quot;

engine.register_type_with_name::&lt;TestStruct&gt;(&quot;Hello&quot;);
engine.register_fn(&quot;new_ts&quot;, TestStruct::new);
let x = new_ts();
print(x.type_of());                                 // prints &quot;Hello&quot;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#custom-type-getters-and-setters" id="custom-type-getters-and-setters">Custom Type Getters and Setters</a></h1>
<p>A custom type can also expose members by registering <code>get</code> and/or <code>set</code> functions.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct TestStruct {
    field: String
}

impl TestStruct {
    // Returning a 'String' is OK - Rhai converts it into 'ImmutableString'
    fn get_field(&amp;mut self) -&gt; String {
        self.field.clone()
    }

    // Remember Rhai uses 'ImmutableString' or '&amp;str' instead of 'String'
    fn set_field(&amp;mut self, new_val: ImmutableString) {
        // Get a 'String' from an 'ImmutableString'
        self.field = (*new_val).clone();
    }

    fn new() -&gt; Self {
        TestStruct { field: &quot;hello&quot; }
    }
}

let mut engine = Engine::new();

engine.register_type::&lt;TestStruct&gt;();

engine.register_get_set(&quot;xyz&quot;, TestStruct::get_field, TestStruct::set_field);
engine.register_fn(&quot;new_ts&quot;, TestStruct::new);

// Return result can be 'String' - Rhai will automatically convert it from 'ImmutableString'
let result = engine.eval::&lt;String&gt;(r#&quot;let a = new_ts(); a.xyz = &quot;42&quot;; a.xyz&quot;#)?;

println!(&quot;Answer: {}&quot;, result);                     // prints 42
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#custom-type-indexers" id="custom-type-indexers">Custom Type Indexers</a></h1>
<p>A custom type can also expose an <em>indexer</em> by registering an indexer function.</p>
<p>A custom type with an indexer function defined can use the bracket ‘<code>[]</code>‘ notation to get a property value.</p>
<p>Indexers are disabled when the <a href="rust//rhai/vnext/start/features.html"><code>no_index</code></a> feature is used.</p>
<p>For efficiency reasons, indexers <strong>cannot</strong> be used to overload (i.e. override) built-in indexing operations for
<a href="rust//rhai/vnext/language/arrays.html">arrays</a> and <a href="rust//rhai/vnext/language/object-maps.html">object maps</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct TestStruct {
    fields: Vec&lt;i64&gt;
}

impl TestStruct {
    fn get_field(&amp;mut self, index: i64) -&gt; i64 {
        self.fields[index as usize]
    }
    fn set_field(&amp;mut self, index: i64, value: i64) {
        self.fields[index as usize] = value
    }

    fn new() -&gt; Self {
        TestStruct { fields: vec![1, 2, 3, 4, 5] }
    }
}

let mut engine = Engine::new();

engine.register_type::&lt;TestStruct&gt;();

engine.register_fn(&quot;new_ts&quot;, TestStruct::new);

// Shorthand: engine.register_indexer_get_set(TestStruct::get_field, TestStruct::set_field);
engine.register_indexer_get(TestStruct::get_field);
engine.register_indexer_set(TestStruct::set_field);

let result = engine.eval::&lt;i64&gt;(&quot;let a = new_ts(); a[2] = 42; a[2]&quot;)?;

println!(&quot;Answer: {}&quot;, result);                     // prints 42
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#disable-custom-types" id="disable-custom-types">Disable Custom Types</a></h1>
<p>The custom types API <code>register_type</code>, <code>register_type_with_name</code>, <code>register_get</code>, <code>register_set</code>, <code>register_get_set</code>,
<code>register_indexer_get</code>, <code>register_indexer_set</code> and <code>register_indexer_get_set</code> are not available under <a href="rust//rhai/vnext/start/features.html"><code>no_object</code></a>.</p>
<p>The indexers API <code>register_indexer_get</code>, <code>register_indexer_set</code> and <code>register_indexer_get_set</code> are also
not available under <a href="rust//rhai/vnext/start/features.html"><code>no_index</code></a>.</p>
<h1><a class="header" href="#printing-for-custom-types" id="printing-for-custom-types">Printing for Custom Types</a></h1>
<p>To use custom types for <a href="rust//rhai/vnext/language/print-debug.html"><code>print</code></a> and <a href="rust//rhai/vnext/language/print-debug.html"><code>debug</code></a>, or convert its value into a <a href="rust//rhai/vnext/language/strings-chars.html">string</a>,
it is necessary that the following functions be registered (assuming the custom type
is <code>T : Display + Debug</code>):</p>
<table><thead><tr><th>Function</th><th>Signature</th><th>Typical implementation</th><th>Usage</th></tr></thead><tbody>
<tr><td><code>to_string</code></td><td><code>|s: &amp;mut T| -&gt; ImmutableString</code></td><td><code>s.to_string().into()</code></td><td>Converts the custom type into a <a href="rust//rhai/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td><code>print</code></td><td><code>|s: &amp;mut T| -&gt; ImmutableString</code></td><td><code>s.to_string().into()</code></td><td>Converts the custom type into a <a href="rust//rhai/vnext/language/strings-chars.html">string</a> for the <a href="rust//rhai/vnext/language/print-debug.html"><code>print</code></a> statement</td></tr>
<tr><td><code>debug</code></td><td><code>|s: &amp;mut T| -&gt; ImmutableString</code></td><td><code>format!(&quot;{:?}&quot;, s).into()</code></td><td>Converts the custom type into a <a href="rust//rhai/vnext/language/strings-chars.html">string</a> for the <a href="rust//rhai/vnext/language/print-debug.html"><code>debug</code></a> statement</td></tr>
<tr><td><code>+</code></td><td><code>|s1: ImmutableString, s: T| -&gt; ImmutableString</code></td><td><code>s1 + s</code></td><td>Append the custom type to another <a href="rust//rhai/vnext/language/strings-chars.html">string</a>, for <code>print(&quot;Answer: &quot; + type);</code> usage</td></tr>
<tr><td><code>+</code></td><td><code>|s: T, s2: ImmutableString| -&gt; ImmutableString</code></td><td><code>s.to_string().push_str(&amp;s2).into();</code></td><td>Append another <a href="rust//rhai/vnext/language/strings-chars.html">string</a> to the custom type, for <code>print(type + &quot; is the answer&quot;);</code> usage</td></tr>
<tr><td><code>+=</code></td><td><code>|s1: &amp;mut ImmutableString, s: T|</code></td><td><code>s1 += s.to_string()</code></td><td>Append the custom type to an existing <a href="rust//rhai/vnext/language/strings-chars.html">string</a>, for <code>s += type;</code> usage</td></tr>
</tbody></table>
<h1><a class="header" href="#scope---initializing-and-maintaining-state" id="scope---initializing-and-maintaining-state"><code>Scope</code> - Initializing and Maintaining State</a></h1>
<p>By default, Rhai treats each <a href="rust//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> invocation as a fresh one, persisting only the functions that have been defined
but no global state. This gives each evaluation a clean starting slate.</p>
<p>In order to continue using the same global state from one invocation to the next,
such a state must be manually created and passed in.</p>
<p>All <code>Scope</code> variables are <a href="rust//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a>, meaning they can store values of any type.</p>
<p>Under <a href="rust//rhai/vnext/start/features.html"><code>sync</code></a>, however, only types that are <code>Send + Sync</code> are supported, and the entire <code>Scope</code> itself
will also be <code>Send + Sync</code>. This is extremely useful in multi-threaded applications.</p>
<p>In this example, a global state object (a <code>Scope</code>) is created with a few initialized variables,
then the same state is threaded through multiple invocations:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Scope, EvalAltResult};

let engine = Engine::new();

// First create the state
let mut scope = Scope::new();

// Then push (i.e. add) some initialized variables into the state.
// Remember the system number types in Rhai are i64 (i32 if 'only_i32') ond f64.
// Better stick to them or it gets hard working with the script.
scope.push(&quot;y&quot;, 42_i64);
scope.push(&quot;z&quot;, 999_i64);

// 'set_value' adds a variable when one doesn't exist
scope.set_value(&quot;s&quot;, &quot;hello, world!&quot;.to_string());  // remember to use 'String', not '&amp;str'

// First invocation
engine.eval_with_scope::&lt;()&gt;(&amp;mut scope, r&quot;
    let x = 4 + 5 - y + z + s.len;
    y = 1;
&quot;)?;

// Second invocation using the same state
let result = engine.eval_with_scope::&lt;i64&gt;(&amp;mut scope, &quot;x&quot;)?;

println!(&quot;result: {}&quot;, result);                     // prints 979

// Variable y is changed in the script - read it with 'get_value'
assert_eq!(scope.get_value::&lt;i64&gt;(&quot;y&quot;).expect(&quot;variable y should exist&quot;), 1);

// We can modify scope variables directly with 'set_value'
scope.set_value(&quot;y&quot;, 42_i64);
assert_eq!(scope.get_value::&lt;i64&gt;(&quot;y&quot;).expect(&quot;variable y should exist&quot;), 42);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#engine-configuration-options" id="engine-configuration-options">Engine Configuration Options</a></h1>
<p>A number of other configuration options are available from the <code>Engine</code> to fine-tune behavior and safeguards.</p>
<table><thead><tr><th>Method</th><th>Not available under</th><th>Description</th></tr></thead><tbody>
<tr><td><code>set_optimization_level</code></td><td><a href="rust//rhai/vnext/start/features.html"><code>no_optimize</code></a></td><td>Set the amount of script <em>optimizations</em> performed. See <a href="rust//rhai/vnext/engine/optimize/index.html">script optimization</a>.</td></tr>
<tr><td><code>set_max_expr_depths</code></td><td><a href="rust//rhai/vnext/start/features.html"><code>unchecked</code></a></td><td>Set the maximum nesting levels of an expression/statement. See <a href="rust//rhai/vnext/safety/max-stmt-depth.html">maximum statement depth</a>.</td></tr>
<tr><td><code>set_max_call_levels</code></td><td><a href="rust//rhai/vnext/start/features.html"><code>unchecked</code></a></td><td>Set the maximum number of function call levels (default 50) to avoid infinite recursion. See <a href="rust//rhai/vnext/safety/max-call-stack.html">maximum call stack depth</a>.</td></tr>
<tr><td><code>set_max_operations</code></td><td><a href="rust//rhai/vnext/start/features.html"><code>unchecked</code></a></td><td>Set the maximum number of <em>operations</em> that a script is allowed to consume. See <a href="rust//rhai/vnext/safety/max-operations.html">maximum number of operations</a>.</td></tr>
<tr><td><code>set_max_modules</code></td><td><a href="rust//rhai/vnext/start/features.html"><code>unchecked</code></a></td><td>Set the maximum number of <a href="rust//rhai/vnext/language/modules/index.html">modules</a> that a script is allowed to load. See <a href="rust//rhai/vnext/safety/max-modules.html">maximum number of modules</a>.</td></tr>
<tr><td><code>set_max_string_size</code></td><td><a href="rust//rhai/vnext/start/features.html"><code>unchecked</code></a></td><td>Set the maximum length (in UTF-8 bytes) for <a href="rust//rhai/vnext/language/strings-chars.html">strings</a>. See <a href="rust//rhai/vnext/safety/max-string-size.html">maximum length of strings</a>.</td></tr>
<tr><td><code>set_max_array_size</code></td><td><a href="rust//rhai/vnext/start/features.html"><code>unchecked</code></a>, <a href="rust//rhai/vnext/start/features.html"><code>no_index</code></a></td><td>Set the maximum size for <a href="rust//rhai/vnext/language/arrays.html">arrays</a>. See <a href="rust//rhai/vnext/safety/max-array-size.html">maximum size of arrays</a>.</td></tr>
<tr><td><code>set_max_map_size</code></td><td><a href="rust//rhai/vnext/start/features.html"><code>unchecked</code></a>, <a href="rust//rhai/vnext/start/features.html"><code>no_object</code></a></td><td>Set the maximum number of properties for <a href="rust//rhai/vnext/language/object-maps.html">object maps</a>. See <a href="rust//rhai/vnext/safety/max-map-size.html">maximum size of object maps</a>.</td></tr>
</tbody></table>
<h1><a class="header" href="#rhai-language-reference" id="rhai-language-reference">Rhai Language Reference</a></h1>
<p>This section outlines the Rhai language.</p>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>Comments are C-style, including ‘<code>/*</code> ... <code>*/</code>‘ pairs and ‘<code>//</code>‘ for comments to the end of the line.
Comments can be nested.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let /* intruder comment */ name = &quot;Bob&quot;;

// This is a very important comment

/* This comment spans
   multiple lines, so it
   only makes sense that
   it is even more important */

/* Fear not, Rhai satisfies all nesting needs with nested comments:
   /*/*/*/*/**/*/*/*/*/
*/
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#values-and-types" id="values-and-types">Values and Types</a></h1>
<p>The following primitive types are supported natively:</p>
<table><thead><tr><th>Category</th><th>Equivalent Rust types</th><th><a href="language//rhai/vnext/language/type-of.html"><code>type_of()</code></a></th><th><code>to_string()</code></th></tr></thead><tbody>
<tr><td><strong>Integer number</strong></td><td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <br/><code>u32</code>, <code>i32</code> (default for <a href="language//rhai/vnext/start/features.html"><code>only_i32</code></a>),<br/><code>u64</code>, <code>i64</code> <em>(default)</em></td><td><code>&quot;i32&quot;</code>, <code>&quot;u64&quot;</code> etc.</td><td><code>&quot;42&quot;</code>, <code>&quot;123&quot;</code> etc.</td></tr>
<tr><td><strong>Floating-point number</strong> (disabled with <a href="language//rhai/vnext/start/features.html"><code>no_float</code></a>)</td><td><code>f32</code>, <code>f64</code> <em>(default)</em></td><td><code>&quot;f32&quot;</code> or <code>&quot;f64&quot;</code></td><td><code>&quot;123.4567&quot;</code> etc.</td></tr>
<tr><td><strong>Boolean value</strong></td><td><code>bool</code></td><td><code>&quot;bool&quot;</code></td><td><code>&quot;true&quot;</code> or <code>&quot;false&quot;</code></td></tr>
<tr><td><strong>Unicode character</strong></td><td><code>char</code></td><td><code>&quot;char&quot;</code></td><td><code>&quot;A&quot;</code>, <code>&quot;x&quot;</code> etc.</td></tr>
<tr><td><strong>Immutable Unicode <a href="language//rhai/vnext/language/strings-chars.html">string</a></strong></td><td><code>rhai::ImmutableString</code> (implemented as <code>Rc&lt;String&gt;</code> or <code>Arc&lt;String&gt;</code>)</td><td><code>&quot;string&quot;</code></td><td><code>&quot;hello&quot;</code> etc.</td></tr>
<tr><td><strong><a href="language//rhai/vnext/language/arrays.html"><code>Array</code></a></strong> (disabled with <a href="language//rhai/vnext/start/features.html"><code>no_index</code></a>)</td><td><code>rhai::Array</code></td><td><code>&quot;array&quot;</code></td><td><code>&quot;[ ?, ?, ? ]&quot;</code></td></tr>
<tr><td><strong><a href="language//rhai/vnext/language/object-maps.html">Object map</a></strong> (disabled with <a href="language//rhai/vnext/start/features.html"><code>no_object</code></a>)</td><td><code>rhai::Map</code></td><td><code>&quot;map&quot;</code></td><td><code>&quot;#{ &quot;a&quot;: 1, &quot;b&quot;: 2 }&quot;</code></td></tr>
<tr><td><strong><a href="language//rhai/vnext/language/timestamps.html">Timestamp</a></strong> (implemented in the <a href="language//rhai/vnext/rust/packages/index.html"><code>BasicTimePackage</code></a>, disabled with <a href="language//rhai/vnext/start/features.html"><code>no_std</code></a>)</td><td><code>std::time::Instant</code> (<a href="https://crates.io/crates/instant"><code>instant::Instant</code></a> if not <a href="language//rhai/vnext/start/builds/wasm.html">WASM</a> build)</td><td><code>&quot;timestamp&quot;</code></td><td><em>not supported</em></td></tr>
<tr><td><strong><a href="language//rhai/vnext/language/fn-ptr.html">Function pointer</a></strong></td><td><em>None</em></td><td><code>Fn</code></td><td><code>&quot;Fn(foo)&quot;</code></td></tr>
<tr><td><strong><a href="language//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> value</strong> (i.e. can be anything)</td><td><code>rhai::Dynamic</code></td><td><em>the actual type</em></td><td><em>actual value</em></td></tr>
<tr><td><strong>System integer</strong> (current configuration)</td><td><code>rhai::INT</code> (<code>i32</code> or <code>i64</code>)</td><td><code>&quot;i32&quot;</code> or <code>&quot;i64&quot;</code></td><td><code>&quot;42&quot;</code>, <code>&quot;123&quot;</code> etc.</td></tr>
<tr><td><strong>System floating-point</strong> (current configuration, disabled with <a href="language//rhai/vnext/start/features.html"><code>no_float</code></a>)</td><td><code>rhai::FLOAT</code> (<code>f32</code> or <code>f64</code>)</td><td><code>&quot;f32&quot;</code> or <code>&quot;f64&quot;</code></td><td><code>&quot;123.456&quot;</code> etc.</td></tr>
<tr><td><strong>Nothing/void/nil/null/Unit</strong> (or whatever it is called)</td><td><code>()</code></td><td><code>&quot;()&quot;</code></td><td><code>&quot;&quot;</code> <em>(empty string)</em></td></tr>
</tbody></table>
<p>All types are treated strictly separate by Rhai, meaning that <code>i32</code> and <code>i64</code> and <code>u32</code> are completely different -
they even cannot be added together. This is very similar to Rust.</p>
<p>The default integer type is <code>i64</code>. If other integer types are not needed, it is possible to exclude them and make a
smaller build with the <a href="language//rhai/vnext/start/features.html"><code>only_i64</code></a> feature.</p>
<p>If only 32-bit integers are needed, enabling the <a href="language//rhai/vnext/start/features.html"><code>only_i32</code></a> feature will remove support for all integer types other than <code>i32</code>, including <code>i64</code>.
This is useful on some 32-bit targets where using 64-bit integers incur a performance penalty.</p>
<p>If no floating-point is needed or supported, use the <a href="language//rhai/vnext/start/features.html"><code>no_float</code></a> feature to remove it.</p>
<p><a href="language//rhai/vnext/language/strings-chars.html">Strings</a> in Rhai are <em>immutable</em>, meaning that they can be shared but not modified.  In actual, the <code>ImmutableString</code> type
is an alias to <code>Rc&lt;String&gt;</code> or <code>Arc&lt;String&gt;</code> (depending on the <a href="language//rhai/vnext/start/features.html"><code>sync</code></a> feature).
Any modification done to a Rhai string will cause the string to be cloned and the modifications made to the copy.</p>
<p>The <code>to_string</code> function converts a standard type into a <a href="language//rhai/vnext/language/strings-chars.html">string</a> for display purposes.</p>
<h1><a class="header" href="#dynamic-values" id="dynamic-values">Dynamic Values</a></h1>
<p>A <code>Dynamic</code> value can be <em>any</em> type. However, under <a href="language//rhai/vnext/start/features.html"><code>sync</code></a>, all types must be <code>Send + Sync</code>.</p>
<h2><a class="header" href="#use-a-hreflanguagerhaivnextlanguagetype-ofhtmltype_ofa-to-get-value-type" id="use-a-hreflanguagerhaivnextlanguagetype-ofhtmltype_ofa-to-get-value-type">Use <a href="language//rhai/vnext/language/type-of.html"><code>type_of()</code></a> to Get Value Type</a></h2>
<p>Because <a href="language//rhai/vnext/language/type-of.html"><code>type_of()</code></a> a <code>Dynamic</code> value returns the type of the actual value,
it is usually used to perform type-specific actions based on the actual value’s type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mystery = get_some_dynamic_value();

if type_of(mystery) == &quot;i64&quot; {
    print(&quot;Hey, I got an integer here!&quot;);
} else if type_of(mystery) == &quot;f64&quot; {
    print(&quot;Hey, I got a float here!&quot;);
} else if type_of(mystery) == &quot;string&quot; {
    print(&quot;Hey, I got a string here!&quot;);
} else if type_of(mystery) == &quot;bool&quot; {
    print(&quot;Hey, I got a boolean here!&quot;);
} else if type_of(mystery) == &quot;array&quot; {
    print(&quot;Hey, I got an array here!&quot;);
} else if type_of(mystery) == &quot;map&quot; {
    print(&quot;Hey, I got an object map here!&quot;);
} else if type_of(mystery) == &quot;Fn&quot; {
    print(&quot;Hey, I got a function pointer here!&quot;);
} else if type_of(mystery) == &quot;TestStruct&quot; {
    print(&quot;Hey, I got the TestStruct custom type here!&quot;);
} else {
    print(&quot;I don't know what this is: &quot; + type_of(mystery));
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#functions-returning-dynamic" id="functions-returning-dynamic">Functions Returning <code>Dynamic</code></a></h2>
<p>In Rust, sometimes a <code>Dynamic</code> forms part of a returned value - a good example is an <a href="language//rhai/vnext/language/arrays.html">array</a>
which contains <code>Dynamic</code> elements, or an <a href="language//rhai/vnext/language/object-maps.html">object map</a> which contains <code>Dynamic</code> property values.</p>
<p>To get the <em>real</em> values, the actual value types <em>must</em> be known in advance.
There is no easy way for Rust to decide, at run-time, what type the <code>Dynamic</code> value is
(short of using the <code>type_name</code> function and match against the name).</p>
<h2><a class="header" href="#type-checking-and-casting" id="type-checking-and-casting">Type Checking and Casting</a></h2>
<p>A <code>Dynamic</code> value’s actual type can be checked via the <code>is</code> method.</p>
<p>The <code>cast</code> method then converts the value into a specific, known type.</p>
<p>Alternatively, use the <code>try_cast</code> method which does not panic but returns <code>None</code> when the cast fails.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let list: Array = engine.eval(&quot;...&quot;)?;          // return type is 'Array'
let item = list[0];                             // an element in an 'Array' is 'Dynamic'

item.is::&lt;i64&gt;() == true;                       // 'is' returns whether a 'Dynamic' value is of a particular type

let value = item.cast::&lt;i64&gt;();                 // if the element is 'i64', this succeeds; otherwise it panics
let value: i64 = item.cast();                   // type can also be inferred

let value = item.try_cast::&lt;i64&gt;().unwrap();    // 'try_cast' does not panic when the cast fails, but returns 'None'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#type-name" id="type-name">Type Name</a></h2>
<p>The <code>type_name</code> method gets the name of the actual type as a static string slice,
which can be <code>match</code>-ed against.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let list: Array = engine.eval(&quot;...&quot;)?;          // return type is 'Array'
let item = list[0];                             // an element in an 'Array' is 'Dynamic'

match item.type_name() {                        // 'type_name' returns the name of the actual Rust type
    &quot;i64&quot; =&gt; ...
    &quot;alloc::string::String&quot; =&gt; ...
    &quot;bool&quot; =&gt; ...
    &quot;path::to::module::TestStruct&quot; =&gt; ...
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#conversion-traits" id="conversion-traits">Conversion Traits</a></h2>
<p>The following conversion traits are implemented for <code>Dynamic</code>:</p>
<ul>
<li><code>From&lt;i64&gt;</code> (<code>i32</code> if <a href="language//rhai/vnext/start/features.html"><code>only_i32</code></a>)</li>
<li><code>From&lt;f64&gt;</code> (if not <a href="language//rhai/vnext/start/features.html"><code>no_float</code></a>)</li>
<li><code>From&lt;bool&gt;</code></li>
<li><code>From&lt;rhai::ImmutableString&gt;</code></li>
<li><code>From&lt;String&gt;</code></li>
<li><code>From&lt;char&gt;</code></li>
<li><code>From&lt;Vec&lt;T&gt;&gt;</code> (into an <a href="language//rhai/vnext/language/arrays.html">array</a>)</li>
<li><code>From&lt;HashMap&lt;String, T&gt;&gt;</code> (into an <a href="language//rhai/vnext/language/object-maps.html">object map</a>).</li>
</ul>
<h1><a class="header" href="#type_of" id="type_of"><code>type_of</code></a></h1>
<p>The <code>type_of</code> function detects the actual type of a value.</p>
<p>This is useful because all variables are <a href="language//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> in nature.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Use 'type_of()' to get the actual types of values
type_of('c') == &quot;char&quot;;
type_of(42) == &quot;i64&quot;;

let x = 123;
x.type_of() == &quot;i64&quot;;       // method-call style is also OK
type_of(x) == &quot;i64&quot;;

x = 99.999;
type_of(x) == &quot;f64&quot;;

x = &quot;hello&quot;;
if type_of(x) == &quot;string&quot; {
    do_something_with_string(x);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#numbers" id="numbers">Numbers</a></h1>
<p>Integer numbers follow C-style format with support for decimal, binary (’<code>0b</code>‘), octal (’<code>0o</code>‘) and hex (’<code>0x</code>‘) notations.</p>
<p>The default system integer type (also aliased to <code>INT</code>) is <code>i64</code>. It can be turned into <code>i32</code> via the <a href="language//rhai/vnext/start/features.html"><code>only_i32</code></a> feature.</p>
<p>Floating-point numbers are also supported if not disabled with <a href="language//rhai/vnext/start/features.html"><code>no_float</code></a>. The default system floating-point type is <code>i64</code>
(also aliased to <code>FLOAT</code>).</p>
<p>‘<code>_</code>‘ separators can be added freely and are ignored within a number.</p>
<table><thead><tr><th>Format</th><th>Type</th></tr></thead><tbody>
<tr><td><code>123_345</code>, <code>-42</code></td><td><code>i64</code> in decimal</td></tr>
<tr><td><code>0o07_76</code></td><td><code>i64</code> in octal</td></tr>
<tr><td><code>0xabcd_ef</code></td><td><code>i64</code> in hex</td></tr>
<tr><td><code>0b0101_1001</code></td><td><code>i64</code> in binary</td></tr>
<tr><td><code>123_456.789</code></td><td><code>f64</code></td></tr>
</tbody></table>
<h1><a class="header" href="#numeric-operators" id="numeric-operators">Numeric Operators</a></h1>
<p>Numeric operators generally follow C styles.</p>
<h2><a class="header" href="#unary-operators" id="unary-operators">Unary Operators</a></h2>
<table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>Plus</td></tr>
<tr><td><code>-</code></td><td>Negative</td></tr>
</tbody></table>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let number = -5;

number = -5 - +5;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#binary-operators" id="binary-operators">Binary Operators</a></h2>
<table><thead><tr><th>Operator</th><th>Description</th><th align="center">Integers only</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>Plus</td><td align="center"></td></tr>
<tr><td><code>-</code></td><td>Minus</td><td align="center"></td></tr>
<tr><td><code>*</code></td><td>Multiply</td><td align="center"></td></tr>
<tr><td><code>/</code></td><td>Divide (integer division if acting on integer types)</td><td align="center"></td></tr>
<tr><td><code>%</code></td><td>Modulo (remainder)</td><td align="center"></td></tr>
<tr><td><code>~</code></td><td>Power</td><td align="center"></td></tr>
<tr><td><code>&amp;</code></td><td>Bit-wise <em>And</em></td><td align="center">Yes</td></tr>
<tr><td><code>|</code></td><td>Bit-wise <em>Or</em></td><td align="center">Yes</td></tr>
<tr><td><code>^</code></td><td>Bit-wise <em>Xor</em></td><td align="center">Yes</td></tr>
<tr><td><code>&lt;&lt;</code></td><td>Left bit-shift</td><td align="center">Yes</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Right bit-shift</td><td align="center">Yes</td></tr>
</tbody></table>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = (1 + 2) * (6 - 4) / 2;  // arithmetic, with parentheses

let reminder = 42 % 10;         // modulo

let power = 42 ~ 2;             // power (i64 and f64 only)

let left_shifted = 42 &lt;&lt; 3;     // left shift

let right_shifted = 42 &gt;&gt; 3;    // right shift

let bit_op = 42 | 99;           // bit masking
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#numeric-functions" id="numeric-functions">Numeric Functions</a></h1>
<h2><a class="header" href="#integer-functions" id="integer-functions">Integer Functions</a></h2>
<p>The following standard functions (defined in the <a href="language//rhai/vnext/rust/packages/index.html"><code>BasicMathPackage</code></a> but excluded if using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>)
operate on <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>f32</code> and <code>f64</code> only:</p>
<table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>abs</code></td><td>absolute value</td></tr>
<tr><td><code>sign</code></td><td>returns -1 if the number is negative, +1 if positive, 0 if zero</td></tr>
<tr><td><a href="language//rhai/vnext/language/convert.html"><code>to_float</code></a></td><td>converts an integer type to <code>f64</code></td></tr>
</tbody></table>
<h2><a class="header" href="#floating-point-functions" id="floating-point-functions">Floating-Point Functions</a></h2>
<p>The following standard functions (defined in the <a href="language//rhai/vnext/rust/packages/index.html"><code>BasicMathPackage</code></a> but excluded if using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>)
operate on <code>f64</code> only:</p>
<table><thead><tr><th>Category</th><th>Functions</th></tr></thead><tbody>
<tr><td>Trigonometry</td><td><code>sin</code>, <code>cos</code>, <code>tan</code>, <code>sinh</code>, <code>cosh</code>, <code>tanh</code> in degrees</td></tr>
<tr><td>Arc-trigonometry</td><td><code>asin</code>, <code>acos</code>, <code>atan</code>, <code>asinh</code>, <code>acosh</code>, <code>atanh</code> in degrees</td></tr>
<tr><td>Square root</td><td><code>sqrt</code></td></tr>
<tr><td>Exponential</td><td><code>exp</code> (base <em>e</em>)</td></tr>
<tr><td>Logarithmic</td><td><code>ln</code> (base <em>e</em>), <code>log10</code> (base 10), <code>log</code> (any base)</td></tr>
<tr><td>Rounding</td><td><code>floor</code>, <code>ceiling</code>, <code>round</code>, <code>int</code>, <code>fraction</code> methods and properties</td></tr>
<tr><td>Conversion</td><td><a href="language//rhai/vnext/language/convert.html"><code>to_int</code></a></td></tr>
<tr><td>Testing</td><td><code>is_nan</code>, <code>is_finite</code>, <code>is_infinite</code> methods and properties</td></tr>
</tbody></table>
<h1><a class="header" href="#value-conversions" id="value-conversions">Value Conversions</a></h1>
<p>The <code>to_float</code> function converts a supported number to <code>FLOAT</code> (defaults to <code>f64</code>).</p>
<p>The <code>to_int</code> function converts a supported number to <code>INT</code> (<code>i32</code> or <code>i64</code> depending on <a href="language//rhai/vnext/start/features.html"><code>only_i32</code></a>).</p>
<p>That’s it; for other conversions, register custom conversion functions.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 42;

let y = x * 100.0;              // &lt;- error: cannot multiply i64 with f64

let y = x.to_float() * 100.0;   // works

let z = y.to_int() + x;         // works

let c = 'X';                    // character

print(&quot;c is '&quot; + c + &quot;' and its code is &quot; + c.to_int());    // prints &quot;c is 'X' and its code is 88&quot;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#strings-and-characters" id="strings-and-characters">Strings and Characters</a></h1>
<p>String in Rhai contain any text sequence of valid Unicode characters.
Internally strings are stored in UTF-8 encoding.</p>
<p>Strings can be built up from other strings and types via the <code>+</code> operator (provided by the <a href="language//rhai/vnext/rust/packages/index.html"><code>MoreStringPackage</code></a>
but excluded if using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>). This is particularly useful when printing output.</p>
<p><a href="language//rhai/vnext/language/type-of.html"><code>type_of()</code></a> a string returns <code>&quot;string&quot;</code>.</p>
<p>The maximum allowed length of a string can be controlled via <code>Engine::set_max_string_size</code>
(see <a href="language//rhai/vnext/safety/max-string-size.html">maximum length of strings</a>).</p>
<h2><a class="header" href="#the-immutablestring-type" id="the-immutablestring-type">The <code>ImmutableString</code> Type</a></h2>
<p>All strings in Rhai are implemented as <code>ImmutableString</code> (see <a href="language//rhai/vnext/language/values-and-types.html">standard types</a>).</p>
<p><code>ImmutableString</code> should be used in place of the standard Rust type <code>String</code> when registering functions.</p>
<h2><a class="header" href="#string-and-character-literals" id="string-and-character-literals">String and Character Literals</a></h2>
<p>String and character literals follow C-style formatting, with support for Unicode (’<code>\u</code><em>xxxx</em>‘ or ‘<code>\U</code><em>xxxxxxxx</em>‘)
and hex (’<code>\x</code><em>xx</em>‘) escape sequences.</p>
<p>Hex sequences map to ASCII characters, while ‘<code>\u</code>‘ maps to 16-bit common Unicode code points and ‘<code>\U</code>‘ maps the full,
32-bit extended Unicode code points.</p>
<p>Standard escape sequences:</p>
<table><thead><tr><th>Escape sequence</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>\\</code></td><td>back-slash <code>\</code></td></tr>
<tr><td><code>\t</code></td><td>tab</td></tr>
<tr><td><code>\r</code></td><td>carriage-return <code>CR</code></td></tr>
<tr><td><code>\n</code></td><td>line-feed <code>LF</code></td></tr>
<tr><td><code>\&quot;</code></td><td>double-quote <code>&quot;</code> in strings</td></tr>
<tr><td><code>\'</code></td><td>single-quote <code>'</code> in characters</td></tr>
<tr><td><code>\x</code><em>xx</em></td><td>Unicode in 2-digit hex</td></tr>
<tr><td><code>\u</code><em>xxxx</em></td><td>Unicode in 4-digit hex</td></tr>
<tr><td><code>\U</code><em>xxxxxxxx</em></td><td>Unicode in 8-digit hex</td></tr>
</tbody></table>
<h2><a class="header" href="#differences-from-rust-strings" id="differences-from-rust-strings">Differences from Rust Strings</a></h2>
<p>Internally Rhai strings are stored as UTF-8 just like Rust (they <em>are</em> Rust <code>String</code>‘s!),
but nevertheless there are major differences.</p>
<p>In Rhai a string is the same as an array of Unicode characters and can be directly indexed (unlike Rust).</p>
<p>This is similar to most other languages where strings are internally represented not as UTF-8 but as arrays of multi-byte
Unicode characters.</p>
<p>Individual characters within a Rhai string can also be replaced just as if the string is an array of Unicode characters.</p>
<p>In Rhai, there is also no separate concepts of <code>String</code> and <code>&amp;str</code> as in Rust.</p>
<h2><a class="header" href="#immutable-strings" id="immutable-strings">Immutable Strings</a></h2>
<p>Rhai strings are <em>immutable</em> and can be shared.</p>
<p>Modifying a Rhai string actually causes it first to be cloned, and then the modification made to the copy.</p>
<h2><a class="header" href="#examples-1" id="examples-1">Examples</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let name = &quot;Bob&quot;;
let middle_initial = 'C';
let last = &quot;Davis&quot;;

let full_name = name + &quot; &quot; + middle_initial + &quot;. &quot; + last;
full_name == &quot;Bob C. Davis&quot;;

// String building with different types
let age = 42;
let record = full_name + &quot;: age &quot; + age;
record == &quot;Bob C. Davis: age 42&quot;;

// Unlike Rust, Rhai strings can be indexed to get a character
// (disabled with 'no_index')
let c = record[4];
c == 'C';

ts.s = record;                          // custom type properties can take strings

let c = ts.s[4];
c == 'C';

let c = &quot;foo&quot;[0];                       // indexing also works on string literals...
c == 'f';

let c = (&quot;foo&quot; + &quot;bar&quot;)[5];             // ... and expressions returning strings
c == 'r';

// Escape sequences in strings
record += &quot; \u2764\n&quot;;                  // escape sequence of '❤' in Unicode
record == &quot;Bob C. Davis: age 42 ❤\n&quot;;   // '\n' = new-line

// Unlike Rust, Rhai strings can be directly modified character-by-character
// (disabled with 'no_index')
record[4] = '\x58'; // 0x58 = 'X'
record == &quot;Bob X. Davis: age 42 ❤\n&quot;;

// Use 'in' to test if a substring (or character) exists in a string
&quot;Davis&quot; in record == true;
'X' in record == true;
'C' in record == false;

// Strings can be iterated with a 'for' statement, yielding characters
for ch in record {
    print(ch);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#built-in-string-functions" id="built-in-string-functions">Built-in String Functions</a></h1>
<p>The following standard methods (mostly defined in the <a href="language//rhai/vnext/rust/packages/index.html"><code>MoreStringPackage</code></a> but excluded if
using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>) operate on <a href="language//rhai/vnext/language/strings-chars.html">strings</a>:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>len</code> method and property</td><td><em>none</em></td><td>returns the number of characters (not number of bytes) in the string</td></tr>
<tr><td><code>pad</code></td><td>character to pad, target length</td><td>pads the string with an character to at least a specified length</td></tr>
<tr><td><code>+=</code> operator, <code>append</code></td><td>character/string to append</td><td>Adds a character or a string to the end of another string</td></tr>
<tr><td><code>clear</code></td><td><em>none</em></td><td>empties the string</td></tr>
<tr><td><code>truncate</code></td><td>target length</td><td>cuts off the string at exactly a specified number of characters</td></tr>
<tr><td><code>contains</code></td><td>character/sub-string to search for</td><td>checks if a certain character or sub-string occurs in the string</td></tr>
<tr><td><code>index_of</code></td><td>character/sub-string to search for, start index <em>(optional)</em></td><td>returns the index that a certain character or sub-string occurs in the string, or -1 if not found</td></tr>
<tr><td><code>sub_string</code></td><td>start index, length <em>(optional)</em></td><td>extracts a sub-string (to the end of the string if length is not specified)</td></tr>
<tr><td><code>crop</code></td><td>start index, length <em>(optional)</em></td><td>retains only a portion of the string (to the end of the string if length is not specified)</td></tr>
<tr><td><code>replace</code></td><td>target character/sub-string, replacement character/string</td><td>replaces a sub-string with another</td></tr>
<tr><td><code>trim</code></td><td><em>none</em></td><td>trims the string of whitespace at the beginning and end</td></tr>
</tbody></table>
<h2><a class="header" href="#examples-2" id="examples-2">Examples</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let full_name == &quot; Bob C. Davis &quot;;
full_name.len == 14;

full_name.trim();
full_name.len == 12;
full_name == &quot;Bob C. Davis&quot;;

full_name.pad(15, '$');
full_name.len == 15;
full_name == &quot;Bob C. Davis$$$&quot;;

let n = full_name.index_of('$');
n == 12;

full_name.index_of(&quot;$$&quot;, n + 1) == 13;

full_name.sub_string(n, 3) == &quot;$$$&quot;;

full_name.truncate(6);
full_name.len == 6;
full_name == &quot;Bob C.&quot;;

full_name.replace(&quot;Bob&quot;, &quot;John&quot;);
full_name.len == 7;
full_name == &quot;John C.&quot;;

full_name.contains('C') == true;
full_name.contains(&quot;John&quot;) == true;

full_name.crop(5);
full_name == &quot;C.&quot;;

full_name.crop(0, 1);
full_name == &quot;C&quot;;

full_name.clear();
full_name.len == 0;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#arrays" id="arrays">Arrays</a></h1>
<p>Arrays are first-class citizens in Rhai. Like C, arrays are accessed with zero-based, non-negative integer indices.</p>
<p>Array literals are built within square brackets ‘<code>[</code>‘ ... ‘<code>]</code>‘ and separated by commas ‘<code>,</code>‘.</p>
<p>All elements stored in an array are <a href="language//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a>, and the array can freely grow or shrink with elements added or removed.</p>
<p>The Rust type of a Rhai array is <code>rhai::Array</code>.</p>
<p><a href="language//rhai/vnext/language/type-of.html"><code>type_of()</code></a> an array returns <code>&quot;array&quot;</code>.</p>
<p>Arrays are disabled via the <a href="language//rhai/vnext/start/features.html"><code>no_index</code></a> feature.</p>
<p>The maximum allowed size of an array can be controlled via <code>Engine::set_max_array_size</code>
(see <a href="language//rhai/vnext/safety/max-array-size.html">maximum size of arrays</a>.</p>
<h2><a class="header" href="#built-in-functions" id="built-in-functions">Built-in Functions</a></h2>
<p>The following methods (mostly defined in the <a href="language//rhai/vnext/rust/packages/index.html"><code>BasicArrayPackage</code></a> but excluded if using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>) operate on arrays:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>push</code></td><td>element to insert</td><td>inserts an element at the end</td></tr>
<tr><td><code>+=</code> operator, <code>append</code></td><td>array to append</td><td>concatenates the second array to the end of the first</td></tr>
<tr><td><code>+</code> operator</td><td>first array, second array</td><td>concatenates the first array with the second</td></tr>
<tr><td><code>insert</code></td><td>element to insert, position<br/>(beginning if &lt;= 0, end if &gt;= length)</td><td>insert an element at a certain index</td></tr>
<tr><td><code>pop</code></td><td><em>none</em></td><td>removes the last element and returns it (<a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a> if empty)</td></tr>
<tr><td><code>shift</code></td><td><em>none</em></td><td>removes the first element and returns it (<a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a> if empty)</td></tr>
<tr><td><code>remove</code></td><td>index</td><td>removes an element at a particular index and returns it, or returns <a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a> if the index is not valid</td></tr>
<tr><td><code>len</code> method and property</td><td><em>none</em></td><td>returns the number of elements</td></tr>
<tr><td><code>pad</code></td><td>element to pad, target length</td><td>pads the array with an element to at least a specified length</td></tr>
<tr><td><code>clear</code></td><td><em>none</em></td><td>empties the array</td></tr>
<tr><td><code>truncate</code></td><td>target length</td><td>cuts off the array at exactly a specified length (discarding all subsequent elements)</td></tr>
</tbody></table>
<h2><a class="header" href="#examples-3" id="examples-3">Examples</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let y = [2, 3];         // array literal with 2 elements

let y = [2, 3,];        // trailing comma is OK

y.insert(0, 1);         // insert element at the beginning
y.insert(999, 4);       // insert element at the end

y.len == 4;

y[0] == 1;
y[1] == 2;
y[2] == 3;
y[3] == 4;

(1 in y) == true;       // use 'in' to test if an item exists in the array
(42 in y) == false;     // 'in' uses the '==' operator (which users can override)
                        // to check if the target item exists in the array

y[1] = 42;              // array elements can be reassigned

(42 in y) == true;

y.remove(2) == 3;       // remove element

y.len == 3;

y[2] == 4;              // elements after the removed element are shifted

ts.list = y;            // arrays can be assigned completely (by value copy)
let foo = ts.list[1];
foo == 42;

let foo = [1, 2, 3][0];
foo == 1;

fn abc() {
    [42, 43, 44]        // a function returning an array
}

let foo = abc()[0];
foo == 42;

let foo = y[0];
foo == 1;

y.push(4);              // 4 elements
y.push(5);              // 5 elements

y.len == 5;

let first = y.shift();  // remove the first element, 4 elements remaining
first == 1;

let last = y.pop();     // remove the last element, 3 elements remaining
last == 5;

y.len == 3;

for item in y {         // arrays can be iterated with a 'for' statement
    print(item);
}

y.pad(10, &quot;hello&quot;);     // pad the array up to 10 elements

y.len == 10;

y.truncate(5);          // truncate the array to 5 elements

y.len == 5;

y.clear();              // empty the array

y.len == 0;
<span class="boring">}
</span></code></pre></pre>
<p><code>push</code> and <code>pad</code> are only defined for standard built-in types. For custom types, type-specific versions must be registered:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>engine.register_fn(&quot;push&quot;, |list: &amp;mut Array, item: MyType| list.push(Box::new(item)) );
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#object-maps" id="object-maps">Object Maps</a></h1>
<p>Object maps are hash dictionaries. Properties are all <a href="language//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> and can be freely added and retrieved.</p>
<p>The Rust type of a Rhai object map is <code>rhai::Map</code>.</p>
<p><a href="language//rhai/vnext/language/type-of.html"><code>type_of()</code></a> an object map returns <code>&quot;map&quot;</code>.</p>
<p>Object maps are disabled via the <a href="language//rhai/vnext/start/features.html"><code>no_object</code></a> feature.</p>
<p>The maximum allowed size of an object map can be controlled via <code>Engine::set_max_map_size</code>
(see <a href="language//rhai/vnext/safety/max-map-size.html">maximum size of object maps</a>).</p>
<h2><a class="header" href="#object-map-literals" id="object-map-literals">Object Map Literals</a></h2>
<p>Object map literals are built within braces ‘<code>#{</code>‘ ... ‘<code>}</code>‘ (<em>name</em> <code>:</code> <em>value</em> syntax similar to Rust)
and separated by commas ‘<code>,</code>‘.  The property <em>name</em> can be a simple variable name following the same
naming rules as <a href="language//rhai/vnext/language/variables.html">variables</a>, or an arbitrary <a href="language//rhai/vnext/language/strings-chars.html">string</a> literal.</p>
<h2><a class="header" href="#access-properties" id="access-properties">Access Properties</a></h2>
<p>Property values can be accessed via the <em>dot</em> notation (<em>object</em> <code>.</code> <em>property</em>)
or <em>index</em> notation (<em>object</em> <code>[</code> <em>property</em> <code>]</code>).</p>
<p>The dot notation allows only property names that follow the same naming rules as <a href="language//rhai/vnext/language/variables.html">variables</a>.</p>
<p>The index notation allows setting/getting properties of arbitrary names (even the empty <a href="language//rhai/vnext/language/strings-chars.html">string</a>).</p>
<p><strong>Important:</strong> Trying to read a non-existent property returns <a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a> instead of causing an error.</p>
<h2><a class="header" href="#built-in-functions-1" id="built-in-functions-1">Built-in Functions</a></h2>
<p>The following methods (defined in the <a href="language//rhai/vnext/rust/packages/index.html"><code>BasicMapPackage</code></a> but excluded if using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>)
operate on object maps:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>has</code></td><td>property name</td><td>does the object map contain a property of a particular name?</td></tr>
<tr><td><code>len</code></td><td><em>none</em></td><td>returns the number of properties</td></tr>
<tr><td><code>clear</code></td><td><em>none</em></td><td>empties the object map</td></tr>
<tr><td><code>remove</code></td><td>property name</td><td>removes a certain property and returns it (<a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a> if the property does not exist)</td></tr>
<tr><td><code>+=</code> operator, <code>mixin</code></td><td>second object map</td><td>mixes in all the properties of the second object map to the first (values of properties with the same names replace the existing values)</td></tr>
<tr><td><code>+</code> operator</td><td>first object map, second object map</td><td>merges the first object map with the second</td></tr>
<tr><td><code>fill_with</code></td><td>second object map</td><td>adds in all properties of the second object map that do not exist in the object map</td></tr>
<tr><td><code>keys</code></td><td><em>none</em></td><td>returns an <a href="language//rhai/vnext/language/arrays.html">array</a> of all the property names (in random order), not available under <a href="language//rhai/vnext/start/features.html"><code>no_index</code></a></td></tr>
<tr><td><code>values</code></td><td><em>none</em></td><td>returns an <a href="language//rhai/vnext/language/arrays.html">array</a> of all the property values (in random order), not available under <a href="language//rhai/vnext/start/features.html"><code>no_index</code></a></td></tr>
</tbody></table>
<h2><a class="header" href="#examples-4" id="examples-4">Examples</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let y = #{              // object map literal with 3 properties
    a: 1,
    bar: &quot;hello&quot;,
    &quot;baz!$@&quot;: 123.456,  // like JavaScript, you can use any string as property names...
    &quot;&quot;: false,          // even the empty string!

    a: 42               // &lt;- syntax error: duplicated property name
};

y.a = 42;               // access via dot notation
y.baz!$@ = 42;          // &lt;- syntax error: only proper variable names allowed in dot notation
y.&quot;baz!$@&quot; = 42;        // &lt;- syntax error: strings not allowed in dot notation

y.a == 42;

y[&quot;baz!$@&quot;] == 123.456; // access via index notation

&quot;baz!$@&quot; in y == true;  // use 'in' to test if a property exists in the object map
(&quot;z&quot; in y) == false;

ts.obj = y;             // object maps can be assigned completely (by value copy)
let foo = ts.list.a;
foo == 42;

let foo = #{ a:1,};     // trailing comma is OK

let foo = #{ a:1, b:2, c:3 }[&quot;a&quot;];
foo == 1;

fn abc() {
<span class="boring">    { a:1, b:2, c:3 }  // a function returning an object map
</span>}

let foo = abc().b;
foo == 2;

let foo = y[&quot;a&quot;];
foo == 42;

y.has(&quot;a&quot;) == true;
y.has(&quot;xyz&quot;) == false;

y.xyz == ();            // a non-existing property returns '()'
y[&quot;xyz&quot;] == ();

y.len() == 3;

y.remove(&quot;a&quot;) == 1;     // remove property

y.len() == 2;
y.has(&quot;a&quot;) == false;

for name in keys(y) {   // get an array of all the property names via the 'keys' function
    print(name);
}

for val in values(y) {  // get an array of all the property values via the 'values' function
    print(val);
}

y.clear();              // empty the object map

y.len() == 0;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#parse-an-object-map-from-json" id="parse-an-object-map-from-json">Parse an Object Map from JSON</a></h1>
<p>The syntax for an <a href="language//rhai/vnext/language/object-maps.html">object map</a> is extremely similar to JSON, with the exception of <code>null</code> values which can
technically be mapped to <a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a>.  A valid JSON string does not start with a hash character <code>#</code> while a
Rhai <a href="language//rhai/vnext/language/object-maps.html">object map</a> does - that’s the major difference!</p>
<p>Use the <code>Engine::parse_json</code> method to parse a piece of JSON into an object map:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// JSON string - notice that JSON property names are always quoted
//               notice also that comments are acceptable within the JSON string
let json = r#&quot;{
                &quot;a&quot;: 1,                 // &lt;- this is an integer number
                &quot;b&quot;: true,
                &quot;c&quot;: 123.0,             // &lt;- this is a floating-point number
                &quot;$d e f!&quot;: &quot;hello&quot;,     // &lt;- any text can be a property name
                &quot;^^^!!!&quot;: [1,42,&quot;999&quot;], // &lt;- value can be array or another hash
                &quot;z&quot;: null               // &lt;- JSON 'null' value
              }
&quot;#;

// Parse the JSON expression as an object map
// Set the second boolean parameter to true in order to map 'null' to '()'
let map = engine.parse_json(json, true)?;

map.len() == 6;                         // 'map' contains all properties in the JSON string

// Put the object map into a 'Scope'
let mut scope = Scope::new();
scope.push(&quot;map&quot;, map);

let result = engine.eval_with_scope::&lt;INT&gt;(r#&quot;map[&quot;^^^!!!&quot;].len()&quot;#)?;

result == 3;                            // the object map is successfully used in the script
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#representation-of-numbers" id="representation-of-numbers">Representation of Numbers</a></h2>
<p>JSON numbers are all floating-point while Rhai supports integers (<code>INT</code>) and floating-point (<code>FLOAT</code>) if
the <a href="language//rhai/vnext/start/features.html"><code>no_float</code></a> feature is not used.  Most common generators of JSON data distinguish between
integer and floating-point values by always serializing a floating-point number with a decimal point
(i.e. <code>123.0</code> instead of <code>123</code> which is assumed to be an integer).  This style can be used successfully
with Rhai <a href="language//rhai/vnext/language/object-maps.html">object maps</a>.</p>
<h1><a class="header" href="#special-support-for-oop-via-object-maps" id="special-support-for-oop-via-object-maps">Special Support for OOP via Object Maps</a></h1>
<p><a href="language//rhai/vnext/language/object-maps.html">Object maps</a> can be used to simulate <a href="language//rhai/vnext/language/oop.html">object-oriented programming (OOP)</a> by storing data
as properties and methods as properties holding <a href="language//rhai/vnext/language/fn-ptr.html">function pointers</a>.</p>
<p>If an <a href="language//rhai/vnext/language/object-maps.html">object map</a>‘s property holds a <a href="language//rhai/vnext/language/fn-ptr.html">function pointer</a>, the property can simply be called like
a normal method in method-call syntax.  This is a <em>short-hand</em> to avoid the more verbose syntax
of using the <code>call</code> function keyword.</p>
<p>When a property holding a <a href="language//rhai/vnext/language/fn-ptr.html">function pointer</a> is called like a method, what happens next depends
on whether the target function is a native Rust function or a script-defined function.</p>
<p>If it is a registered native Rust method function, then it is called directly.</p>
<p>If it is a script-defined function, the <code>this</code> variable within the function body is bound
to the <a href="language//rhai/vnext/language/object-maps.html">object map</a> before the function is called.  There is no way to simulate this behavior
via a normal function-call syntax because all scripted function arguments are passed by value.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn do_action(x) { print(this.data + x); }   // 'this' binds to the object when called

let obj = #{
                data: 40,
                action: Fn(&quot;do_action&quot;)     // 'action' holds a function pointer to 'do_action'
           };

obj.action(2);                              // Short-hand syntax: prints 42

// To achieve the above with normal function pointer calls:
fn do_action(map, x) { print(map.data + x); }

obj.action.call(obj, 2);                    // this call cannot mutate 'obj'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#timestamps" id="timestamps"><code>timestamp</code>‘s</a></h1>
<p>Timestamps are provided by the <a href="language//rhai/vnext/rust/packages/index.html"><code>BasicTimePackage</code></a> (excluded if using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>)
via the <code>timestamp</code> function.</p>
<p>Timestamps are not available under <a href="language//rhai/vnext/start/features.html"><code>no_std</code></a>.</p>
<p>The Rust type of a timestamp is <code>std::time::Instant</code> (<a href="https://crates.io/crates/instant"><code>instant::Instant</code></a> in <a href="language//rhai/vnext/start/builds/wasm.html">WASM</a> builds).</p>
<p><a href="language//rhai/vnext/language/type-of.html"><code>type_of()</code></a> a timestamp returns <code>&quot;timestamp&quot;</code>.</p>
<h2><a class="header" href="#built-in-functions-2" id="built-in-functions-2">Built-in Functions</a></h2>
<p>The following methods (defined in the <a href="language//rhai/vnext/rust/packages/index.html"><code>BasicTimePackage</code></a> but excluded if using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>) operate on timestamps:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>elapsed</code> method and property</td><td><em>none</em></td><td>returns the number of seconds since the timestamp</td></tr>
<tr><td><code>-</code> operator</td><td>later timestamp, earlier timestamp</td><td>returns the number of seconds between the two timestamps</td></tr>
</tbody></table>
<h2><a class="header" href="#examples-5" id="examples-5">Examples</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let now = timestamp();

// Do some lengthy operation...

if now.elapsed &gt; 30.0 {
    print(&quot;takes too long (over 30 seconds)!&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#keywords" id="keywords">Keywords</a></h1>
<p>The following are reserved keywords in Rhai:</p>
<table><thead><tr><th>Keywords</th><th>Usage</th><th align="center">Not available under feature</th></tr></thead><tbody>
<tr><td><code>true</code>, <code>false</code></td><td>Boolean constants</td><td align="center"></td></tr>
<tr><td><code>let</code>, <code>const</code></td><td>Variable declarations</td><td align="center"></td></tr>
<tr><td><code>if</code>, <code>else</code></td><td>Control flow</td><td align="center"></td></tr>
<tr><td><code>while</code>, <code>loop</code>, <code>for</code>, <code>in</code>, <code>continue</code>, <code>break</code></td><td>Looping</td><td align="center"></td></tr>
<tr><td><code>fn</code>, <code>private</code></td><td>Functions</td><td align="center"><a href="language//rhai/vnext/start/features.html"><code>no_function</code></a></td></tr>
<tr><td><code>return</code></td><td>Return values</td><td align="center"></td></tr>
<tr><td><code>throw</code></td><td>throw exceptions</td><td align="center"></td></tr>
<tr><td><code>import</code>, <code>export</code>, <code>as</code></td><td>Modules</td><td align="center"><a href="language//rhai/vnext/start/features.html"><code>no_module</code></a></td></tr>
<tr><td><code>Fn</code>, <code>call</code></td><td>Function pointers</td><td align="center"></td></tr>
<tr><td><code>type_of</code>, <code>print</code>, <code>debug</code>, <code>eval</code></td><td>Special functions</td><td align="center"></td></tr>
</tbody></table>
<p>Keywords cannot be the name of a <a href="language//rhai/vnext/language/functions.html">function</a> or <a href="language//rhai/vnext/language/variables.html">variable</a>, unless the relevant feature is enabled.
For example, <code>fn</code> is a valid variable name under <a href="language//rhai/vnext/start/features.html"><code>no_function</code></a>.</p>
<h1><a class="header" href="#statements" id="statements">Statements</a></h1>
<h2><a class="header" href="#terminated-by-" id="terminated-by-">Terminated by ‘<code>;</code>‘</a></h2>
<p>Statements are terminated by semicolons ‘<code>;</code>‘ and they are mandatory,
except for the <em>last</em> statement in a <em>block</em> (enclosed by ‘<code>{</code>‘ .. ‘<code>}</code>‘ pairs) where it can be omitted.</p>
<p>Semicolons can also be omitted if the statement contains a block itself
(e.g. the <code>if</code>, <code>while</code>, <code>for</code> and <code>loop</code> statements).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 42;             // normal assignment statement
let a = foo(42);        // normal function call statement
foo &lt; 42;               // normal expression as statement

let a = { 40 + 2 };     // 'a' is set to the value of the statement block, which is the value of the last statement
//              ^ the last statement does not require a terminating semicolon (although it also works with it)
//                ^ semicolon required here to terminate the assignment statement; it is a syntax error without it

if foo { a = 42 }
//               ^ there is no need to terminate an if-statement with a semicolon

4 * 10 + 2              // a statement which is just one expression - no ending semicolon is OK
                        // because it is the last statement of the whole block
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#statement-expression" id="statement-expression">Statement Expression</a></h2>
<p>A statement can be used anywhere where an expression is expected. These are called, for lack of a more
creative name, “statement expressions.”</p>
<p>The <em>last</em> statement of a statement block is <em>always</em> the block’s return value when used as a statement.</p>
<p>If the last statement has no return value (e.g. variable definitions, assignments) then it is assumed to be <a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a>.</p>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<h2><a class="header" href="#valid-names" id="valid-names">Valid Names</a></h2>
<p>Variables in Rhai follow normal C naming rules - must contain only ASCII letters, digits and underscores ‘<code>_</code>‘,
and cannot start with a digit.</p>
<p>For example: ‘<code>_c3po</code>‘ and ‘<code>r2d2</code>‘ are valid variable names, but ‘<code>3abc</code>‘ is not.</p>
<p>However, unlike Rust, a variable name must also contain at least one ASCII letter, and an ASCII letter must come before any digit.
In other words, the first character that is not an underscore ‘<code>_</code>‘ must be an ASCII letter and not a digit.</p>
<p>Therefore, some names acceptable to Rust, like ‘<code>_</code>‘, ‘<code>_42foo</code>‘, ‘<code>_1</code>‘ etc., are not valid in Rhai.
This restriction is to reduce confusion because, for instance, ‘<code>_1</code>‘ can easily be misread (or mis-typed) as <code>-1</code>.</p>
<p>Variable names are case <em>sensitive</em>.</p>
<p>Variable names also cannot be the same as a <a href="language//rhai/vnext/appendix/keywords.html">keyword</a>.</p>
<h2><a class="header" href="#declare-a-variable" id="declare-a-variable">Declare a Variable</a></h2>
<p>Variables are declared using the <code>let</code> keyword.</p>
<p>Variables do not have to be given an initial value.
If none is provided, it defaults to <a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a>.</p>
<p>A variable defined within a statement block is <em>local</em> to that block.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x;              // ok - value is '()'
let x = 3;          // ok
let _x = 42;        // ok
let x_ = 42;        // also ok
let _x_ = 42;       // still ok

let _ = 123;        // &lt;- syntax error: illegal variable name
let _9 = 9;         // &lt;- syntax error: illegal variable name

let x = 42;         // variable is 'x', lower case
let X = 123;        // variable is 'X', upper case
x == 42;
X == 123;

{
    let x = 999;    // local variable 'x' shadows the 'x' in parent block
    x == 999;       // access to local 'x'
}
x == 42;            // the parent block's 'x' is not changed
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#constants" id="constants">Constants</a></h1>
<p>Constants can be defined using the <code>const</code> keyword and are immutable.</p>
<p>Constants follow the same naming rules as <a href="language//rhai/vnext/language/variables.html">variables</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const x = 42;

print(x * 2);       // prints 84

x = 123;            // &lt;- syntax error: cannot assign to constant
<span class="boring">}
</span></code></pre></pre>
<p>Unlike variables which need not have initial values (default to <a href="language//rhai/vnext/language/values-and-types.html"><code>()</code></a>),
constants must be assigned one, and it must be a constant <em>value</em>, not an expression.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const x = 40 + 2;   // &lt;- syntax error: cannot assign expression to constant
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#logic-operators" id="logic-operators">Logic Operators</a></h1>
<h2><a class="header" href="#comparison-operators" id="comparison-operators">Comparison Operators</a></h2>
<p>Comparing most values of the same data type work out-of-the-box for all <a href="language//rhai/vnext/language/values-and-types.html">standard types</a> supported by the system.</p>
<p>However, if using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a> without loading any <a href="language//rhai/vnext/rust/packages/index.html">packages</a>, comparisons can only be made between a limited
set of types (see <a href="language//rhai/vnext/engine/raw.html#built-in-operators">built-in operators</a>).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>42 == 42;               // true

42 &gt; 42;                // false

&quot;hello&quot; &gt; &quot;foo&quot;;        // true

&quot;42&quot; == 42;             // false
<span class="boring">}
</span></code></pre></pre>
<p>Comparing two values of <em>different</em> data types, or of unknown data types, always results in <code>false</code>,
except for ‘<code>!=</code>‘ (not equals) which results in <code>true</code>. This is in line with intuition.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>42 == 42.0;             // false - i64 cannot be compared with f64

42 != 42.0;             // true - i64 cannot be compared with f64

42 &gt; &quot;42&quot;;              // false - i64 cannot be compared with string

42 &lt;= &quot;42&quot;;             // false - i64 cannot be compared with string

let ts = new_ts();      // custom type

ts == 42;               // false - types cannot be compared

ts != 42;               // true - types cannot be compared
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#boolean-operators" id="boolean-operators">Boolean operators</a></h2>
<table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody>
<tr><td><code>!</code></td><td>Boolean <em>Not</em></td></tr>
<tr><td><code>&amp;&amp;</code></td><td>Boolean <em>And</em> (short-circuits)</td></tr>
<tr><td><code>||</code></td><td>Boolean <em>Or</em> (short-circuits)</td></tr>
<tr><td><code>&amp;</code></td><td>Boolean <em>And</em> (doesn’t short-circuit)</td></tr>
<tr><td><code>|</code></td><td>Boolean <em>Or</em> (doesn’t short-circuit)</td></tr>
</tbody></table>
<p>Double boolean operators <code>&amp;&amp;</code> and <code>||</code> <em>short-circuit</em>, meaning that the second operand will not be evaluated
if the first one already proves the condition wrong.</p>
<p>Single boolean operators <code>&amp;</code> and <code>|</code> always evaluate both operands.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>a() || b();             // b() is not evaluated if a() is true

a() &amp;&amp; b();             // b() is not evaluated if a() is false

a() | b();              // both a() and b() are evaluated

a() &amp; b();              // both a() and b() are evaluated
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#compound-assignment-operators" id="compound-assignment-operators">Compound Assignment Operators</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let number = 9;

number += 8;            // number = number + 8

number -= 7;            // number = number - 7

number *= 6;            // number = number * 6

number /= 5;            // number = number / 5

number %= 4;            // number = number % 4

number ~= 3;            // number = number ~ 3

number &lt;&lt;= 2;           // number = number &lt;&lt; 2

number &gt;&gt;= 1;           // number = number &gt;&gt; 1

number &amp;= 0x00ff;       // number = number &amp; 0x00ff;

number |= 0x00ff;       // number = number | 0x00ff;

number ^= 0x00ff;       // number = number ^ 0x00ff;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>+=</code> operator can also be used to build <a href="language//rhai/vnext/language/strings-chars.html">strings</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;abc&quot;;
my_str += &quot;ABC&quot;;
my_str += 12345;

my_str == &quot;abcABC12345&quot;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#if-statement" id="if-statement"><code>if</code> Statement</a></h1>
<p><code>if</code> statements follow C syntax:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if foo(x) {
    print(&quot;It's true!&quot;);
} else if bar == baz {
    print(&quot;It's true again!&quot;);
} else if baz.is_foo() {
    print(&quot;Yet again true.&quot;);
} else if foo(bar - baz) {
    print(&quot;True again... this is getting boring.&quot;);
} else {
    print(&quot;It's finally false!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Unlike C, the condition expression does <em>not</em> need to be enclosed in parentheses ‘<code>(</code>‘ .. ‘<code>)</code>‘, but
all branches of the <code>if</code> statement must be enclosed within braces ‘<code>{</code>‘ .. ‘<code>}</code>‘,
even when there is only one statement inside the branch.</p>
<p>Like Rust, there is no ambiguity regarding which <code>if</code> clause a branch belongs to.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Rhai is not C!
if (decision) print(&quot;I've decided!&quot;);
//            ^ syntax error, expecting '{' in statement block
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#if-expressions" id="if-expressions"><code>if</code>-Expressions</a></h2>
<p>Like Rust, <code>if</code> statements can also be used as <em>expressions</em>, replacing the <code>? :</code> conditional operators
in other C-like languages.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// The following is equivalent to C: int x = 1 + (decision ? 42 : 123) / 2;
let x = 1 + if decision { 42 } else { 123 } / 2;
x == 22;

let x = if decision { 42 }; // no else branch defaults to '()'
x == ();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#while-loop" id="while-loop"><code>while</code> Loop</a></h1>
<p><code>while</code> loops follow C syntax.</p>
<p>Like C, <code>continue</code> can be used to skip to the next iteration, by-passing all following statements;
<code>break</code> can be used to break out of the loop unconditionally.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 10;

while x &gt; 0 {
    x = x - 1;
    if x &lt; 6 { continue; }  // skip to the next iteration
    print(x);
    if x == 5 { break; }    // break out of while loop
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#infinite-loop" id="infinite-loop">Infinite <code>loop</code></a></h1>
<p>Infinite loops follow C syntax.</p>
<p>Like C, <code>continue</code> can be used to skip to the next iteration, by-passing all following statements;
<code>break</code> can be used to break out of the loop unconditionally.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 10;

loop {
    x = x - 1;

    if x &gt; 5 { continue; }  // skip to the next iteration

    print(x);

    if x == 0 { break; }    // break out of loop
}
<span class="boring">}
</span></code></pre></pre>
<p>Beware: a <code>loop</code> statement without a <code>break</code> statement inside its loop block is infinite -
there is no way for the loop to stop iterating.</p>
<h1><a class="header" href="#for-loop" id="for-loop"><code>for</code> Loop</a></h1>
<p>Iterating through a range or an <a href="language//rhai/vnext/language/arrays.html">array</a> is provided by the <code>for</code> ... <code>in</code> loop.</p>
<p>Like C, <code>continue</code> can be used to skip to the next iteration, by-passing all following statements;
<code>break</code> can be used to break out of the loop unconditionally.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Iterate through string, yielding characters
let s = &quot;hello, world!&quot;;

for ch in s {
    if ch &gt; 'z' { continue; }   // skip to the next iteration

    print(ch);

    if x == '@' { break; }      // break out of for loop
}

// Iterate through array
let array = [1, 3, 5, 7, 9, 42];

for x in array {
    if x &gt; 10 { continue; }     // skip to the next iteration

    print(x);

    if x == 42 { break; }       // break out of for loop
}

// The 'range' function allows iterating from first to last-1
for x in range(0, 50) {
    if x &gt; 10 { continue; }     // skip to the next iteration

    print(x);

    if x == 42 { break; }       // break out of for loop
}

// The 'range' function also takes a step
for x in range(0, 50, 3) {      // step by 3
    if x &gt; 10 { continue; }     // skip to the next iteration

    print(x);

    if x == 42 { break; }       // break out of for loop
}

// Iterate through object map
let map = #{a:1, b:3, c:5, d:7, e:9};

// Property names are returned in unsorted, random order
for x in keys(map) {
    if x &gt; 10 { continue; }     // skip to the next iteration

    print(x);

    if x == 42 { break; }       // break out of for loop
}

// Property values are returned in unsorted, random order
for val in values(map) {
    print(val);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#return-values" id="return-values">Return Values</a></h1>
<p>The <code>return</code> statement is used to immediately stop evaluation and exist the current context
(typically a function call) yielding a <em>return value</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>return;             // equivalent to return ();

return 123 + 456;   // returns 579
<span class="boring">}
</span></code></pre></pre>
<p>A <code>return</code> statement at <em>global</em> level stop the entire script evaluation,
the return value is taken as the result of the script evaluation.</p>
<h1><a class="header" href="#throw-exception-on-error" id="throw-exception-on-error">Throw Exception on Error</a></h1>
<p>All of <a href="language//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>‘s evaluation/consuming methods return <code>Result&lt;T, Box&lt;rhai::EvalAltResult&gt;&gt;</code>
with <code>EvalAltResult</code> holding error information.</p>
<p>To deliberately return an error during an evaluation, use the <code>throw</code> keyword.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if some_bad_condition_has_happened {
    throw error;    // 'throw' takes a string as the exception text
}

throw;              // defaults to empty exception text: &quot;&quot;
<span class="boring">}
</span></code></pre></pre>
<p>Exceptions thrown via <code>throw</code> in the script can be captured by matching <code>Err(Box&lt;EvalAltResult::ErrorRuntime(</code> <em>reason</em> <code>,</code> <em>position</em> <code>)&gt;)</code>
with the exception text captured by the first parameter.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let result = engine.eval::&lt;i64&gt;(r#&quot;
    let x = 42;

    if x &gt; 0 {
        throw x + &quot; is too large!&quot;;
    }
&quot;#);

println!(result);   // prints &quot;Runtime error: 42 is too large! (line 5, position 15)&quot;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>Rhai supports defining functions in script (unless disabled with <a href="language//rhai/vnext/start/features.html"><code>no_function</code></a>):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn add(x, y) {
    return x + y;
}

fn sub(x, y,) {     // trailing comma in parameters list is OK
    return x - y;
}

print(add(2, 3));   // prints 5
print(sub(2, 3,));  // prints -1 - trailing comma in arguments list is OK
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#implicit-return" id="implicit-return">Implicit Return</a></h2>
<p>Just like in Rust, an implicit return can be used. In fact, the last statement of a block is <em>always</em> the block’s return value
regardless of whether it is terminated with a semicolon <code>';'</code>. This is different from Rust.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn add(x, y) {      // implicit return:
    x + y;          // value of the last statement (no need for ending semicolon)
                    // is used as the return value
}

fn add2(x) {
    return x + 2;   // explicit return
}

print(add(2, 3));   // prints 5
print(add2(42));    // prints 44
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#no-access-to-external-scope" id="no-access-to-external-scope">No Access to External Scope</a></h2>
<p>Functions are not <em>closures</em>. They do not capture the calling environment and can only access their own parameters.
They cannot access variables external to the function itself.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 42;

fn foo() { x }      // &lt;- syntax error: variable 'x' doesn't exist
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#global-definitions-only" id="global-definitions-only">Global Definitions Only</a></h2>
<p>Functions can only be defined at the global level, never inside a block or another function.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Global level is OK
fn add(x, y) {
    x + y
}

// The following will not compile
fn do_addition(x) {
    fn add_y(n) {   // &lt;- syntax error: functions cannot be defined inside another function
        n + y
    }

    add_y(x)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#use-before-definition" id="use-before-definition">Use Before Definition</a></h2>
<p>Unlike C/C++, functions in Rhai can be defined <em>anywhere</em> at global level.
A function does not need to be defined prior to being used in a script;
a statement in the script can freely call a function defined afterwards.</p>
<p>This is similar to Rust and many other modern languages, such as JavaScript’s <code>function</code> keyword.</p>
<h2><a class="header" href="#arguments-passed-by-value" id="arguments-passed-by-value">Arguments Passed by Value</a></h2>
<p>Functions defined in script always take <a href="language//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> parameters (i.e. the parameter can be of any type).
Therefore, functions with the same name and same <em>number</em> of parameters are equivalent.</p>
<p>It is important to remember that all arguments are passed by <em>value</em>, so all Rhai script-defined functions
are <em>pure</em> (i.e. they never modify their arguments).
Any update to an argument will <strong>not</strong> be reflected back to the caller.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn change(s) {      // 's' is passed by value
    s = 42;         // only a COPY of 's' is changed
}

let x = 500;

change(x);

x == 500;           // 'x' is NOT changed!
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#this---simulating-an-object-method" id="this---simulating-an-object-method"><code>this</code> - Simulating an Object Method</a></h2>
<p>Functions can also be called in method-call style.  When this is the case, the keyword ‘<code>this</code>‘
binds to the object in the method call and can be changed.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn change() {       // not that the object does not need a parameter
    this = 42;      // 'this' binds to the object in method-call
}

let x = 500;

x.change();         // call 'change' in method-call style, 'this' binds to 'x'

x == 42;            // 'x' is changed!

change();           // &lt;- error: `this` is unbounded
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#call-method-as-function" id="call-method-as-function">Call Method as Function</a></h1>
<p>Property <a href="language//rhai/vnext/rust/getters-setters.html">getters/setters</a> and <a href="language//rhai/vnext/rust/custom.html">methods</a> in a Rust custom type registered with the <a href="language//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> can be called
just like a regular function.  In fact, like Rust, property getters/setters and object methods
are registered as regular <a href="language//rhai/vnext/language/functions.html">functions</a> in Rhai that take a first <code>&amp;mut</code> parameter.</p>
<p>Unlike functions defined in script (for which all arguments are passed by <em>value</em>),
native Rust functions may mutate the object (or the first argument if called in normal function call style).</p>
<p>However, sometimes it is not as straight-forward, and methods called in function-call style may end up
not muting the object - see the example below. Therefore, it is best to always use method-call style.</p>
<p>Custom types, properties and methods can be disabled via the <a href="language//rhai/vnext/start/features.html"><code>no_object</code></a> feature.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = new_ts();   // constructor function
a.field = 500;      // property setter
a.update();         // method call, 'a' can be modified

update(a);          // &lt;- this de-sugars to 'a.update()' thus if 'a' is a simple variable
                    //    unlike scripted functions, 'a' can be modified and is not a copy

let array = [ a ];

update(array[0]);   // &lt;- 'array[0]' is an expression returning a calculated value,
                    //    a transient (i.e. a copy), so this statement has no effect
                    //    except waste a lot of time cloning

array[0].update();  // &lt;- call in method-call style will update 'a'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#function-overloading" id="function-overloading">Function Overloading</a></h1>
<p><a href="language//rhai/vnext/language/functions.html">Functions</a> defined in script can be <em>overloaded</em> by <em>arity</em> (i.e. they are resolved purely upon the function’s <em>name</em>
and <em>number</em> of parameters, but not parameter <em>types</em> since all parameters are the same type - <a href="language//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a>).</p>
<p>New definitions <em>overwrite</em> previous definitions of the same name and number of parameters.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo(x,y,z) { print(&quot;Three!!! &quot; + x + &quot;,&quot; + y + &quot;,&quot; + z) }

fn foo(x) { print(&quot;One! &quot; + x) }

fn foo(x,y) { print(&quot;Two! &quot; + x + &quot;,&quot; + y) }

fn foo() { print(&quot;None.&quot;) }

fn foo(x) { print(&quot;HA! NEW ONE! &quot; + x) }    // overwrites previous definition

foo(1,2,3);     // prints &quot;Three!!! 1,2,3&quot;

foo(42);        // prints &quot;HA! NEW ONE! 42&quot;

foo(1,2);       // prints &quot;Two!! 1,2&quot;

foo();          // prints &quot;None.&quot;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#function-namespaces" id="function-namespaces">Function Namespaces</a></h1>
<h2><a class="header" href="#each-function-is-a-separate-compilation-unit" id="each-function-is-a-separate-compilation-unit">Each Function is a Separate Compilation Unit</a></h2>
<p><a href="language//rhai/vnext/language/functions.html">Functions</a> in Rhai are <em>pure</em> and they form individual <em>compilation units</em>.
This means that individual functions can be separated, exported, re-grouped, imported,
and generally mix-’n-match-ed with other completely unrelated scripts.</p>
<p>For example, the <code>AST::merge</code> method allows merging all functions in one <a href="language//rhai/vnext/engine/compile.html"><code>AST</code></a> into another,
forming a new, combined, group of functions.</p>
<p>In general, there are two types of <em>namespaces</em> where functions are looked up:</p>
<table><thead><tr><th>Namespace</th><th>Source</th><th>Lookup method</th><th align="center">How Many</th></tr></thead><tbody>
<tr><td>Global</td><td><code>Engine::register_XXX</code> API, <a href="language//rhai/vnext/engine/compile.html"><code>AST</code></a> being evaluated, <a href="language//rhai/vnext/rust/packages/index.html">packages</a> loaded</td><td>Simple function name</td><td align="center">One</td></tr>
<tr><td>Module</td><td><a href="language//rhai/vnext/language/modules/index.html"><code>Module</code></a></td><td>Namespace-qualified function name</td><td align="center">As many as <a href="language//rhai/vnext/language/modules/import.html"><code>import</code></a>-ed</td></tr>
</tbody></table>
<h2><a class="header" href="#global-namespace" id="global-namespace">Global Namespace</a></h2>
<p>There is one <em>global</em> namespace for every <a href="language//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>, which includes:</p>
<ul>
<li>
<p>All the native Rust functions registered via the <code>Engine::register_XXX</code> API.</p>
</li>
<li>
<p>All the Rust functions defined in <a href="language//rhai/vnext/rust/packages/index.html">packages</a> that are loaded into the <a href="language//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>.</p>
</li>
</ul>
<p>In addition, during evaluation of an <a href="language//rhai/vnext/engine/compile.html"><code>AST</code></a>, all script-defined functions bundled together within
the <a href="language//rhai/vnext/engine/compile.html"><code>AST</code></a> are added to the global namespace and override any existing registered functions of
the same names and number of parameters.</p>
<p>Anywhere in a Rhai script, when a function call is made, it is searched within the global namespace.
Therefore, function calls in Rhai are <em>late</em> bound - meaning that the function called cannot be
determined or guaranteed and there is no way to <em>lock down</em> the function being called.
This aspect is very similar to JavaScript before ES6 modules.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Compile a script into AST
let ast1 = engine.compile(
    r#&quot;
        fn message() { &quot;Hello!&quot; }   // greeting message

        fn say_hello() {
            print(message());       // prints message
        }

        say_hello();
    &quot;#
)?;

// Compile another script with an overriding function
let ast2 = engine.compile(r#&quot;fn message() { &quot;Boo!&quot; }&quot;#)?;

// Merge the two AST's
let ast = ast1.merge(ast2);         // 'message' will be overwritten

engine.consume_ast(&amp;ast)?;          // prints 'Boo!'
<span class="boring">}
</span></code></pre></pre>
<p>Therefore, care must be taken when <em>cross-calling</em> functions to make sure that the correct
functions are called.</p>
<p>The only practical way to ensure that a function is a correct one is to use <a href="language//rhai/vnext/language/modules/index.html">modules</a> -
i.e. define the function in a separate module and then <a href="language//rhai/vnext/language/modules/import.html"><code>import</code></a> it:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>message.rhai:

    fn message() { &quot;Hello!&quot; }

script.rhai:

    fn say_hello() {
        import &quot;message&quot; as msg;
        print(msg::message());
    }
    say_hello();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#module-namespaces" id="module-namespaces">Module Namespaces</a></h2>
<p><a href="language//rhai/vnext/language/modules/index.html">Modules</a> can be dynamically loaded into a Rhai script using the <a href="language//rhai/vnext/language/modules/import.html"><code>import</code></a> keyword.
When that happens, functions defined within the <a href="language//rhai/vnext/language/modules/index.html">module</a> can be called with a <em>qualified</em> name.</p>
<p>There is a catch, though, if functions in a module script refer to global functions
defined <em>within the script</em>.  When called later, those functions will be searched in the
current global namespace and may not be found.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>greeting.rhai:

    fn message() { &quot;Hello!&quot; };

    fn say_hello() { print(message()); }

    say_hello();                    // 'message' is looked up in the global namespace

script.rhai:

    import &quot;greeting&quot; as g;
    g::say_hello();                 // &lt;- error: function not found - 'message'
<span class="boring">}
</span></code></pre></pre>
<p>In the example above, although the module <code>greeting.rhai</code> loads fine (<code>&quot;Hello!&quot;</code> is printed),
the subsequent call using the <em>namespace-qualified</em> function name fails to find the same function
‘<code>message</code>‘ which now essentially becomes <code>g::message</code>.  The call fails as there is no more
function named ‘<code>message</code>‘ in the global namespace.</p>
<p>Therefore, when writing functions for a <a href="language//rhai/vnext/language/modules/index.html">module</a>, make sure that those functions are as <em>pure</em>
as possible and avoid cross-calling them from each other.  A <a href="language//rhai/vnext/language/fn-ptr.html">function pointer</a> is a valid technique
to call another function within a module-defined function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>greeting.rhai:

    fn message() { &quot;Hello!&quot; };

    fn say_hello(msg_func) {        // 'msg_func' is a function pointer
        print(msg_func.call());     // call via the function pointer
    }

    say_hello();                    // 'message' is looked up in the global namespace

script.rhai:

    import &quot;greeting&quot; as g;

    fn my_msg() {
        import &quot;greeting&quot; as g;     // &lt;- must import again here...
        g::message()                // &lt;- ... otherwise will not find module 'g'
    }

    g::say_hello(Fn(&quot;my_msg&quot;));     // prints 'Hello!'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#function-pointers" id="function-pointers">Function Pointers</a></h1>
<p>It is possible to store a <em>function pointer</em> in a variable just like a normal value.
In fact, internally a function pointer simply stores the <em>name</em> of the function as a string.</p>
<p>Call a function pointer using the <code>call</code> method, which needs to be called in method-call style.</p>
<h2><a class="header" href="#built-in-methods" id="built-in-methods">Built-in methods</a></h2>
<p>The following standard methods (mostly defined in the <a href="language//rhai/vnext/rust/packages/index.html"><code>BasicFnPackage</code></a> but excluded if
using a <a href="language//rhai/vnext/engine/raw.html">raw <code>Engine</code></a>) operate on <a href="language//rhai/vnext/language/strings-chars.html">strings</a>:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code> method and property</td><td><em>none</em></td><td>returns the name of the function encapsulated by the function pointer</td></tr>
</tbody></table>
<h2><a class="header" href="#examples-6" id="examples-6">Examples</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo(x) { 41 + x }

let func = Fn(&quot;foo&quot;);       // use the 'Fn' function to create a function pointer

print(func);                // prints 'Fn(foo)'

let func = fn_name.Fn();    // &lt;- error: 'Fn' cannot be called in method-call style

func.type_of() == &quot;Fn&quot;;     // type_of() as function pointer is 'Fn'

func.name == &quot;foo&quot;;

func.call(1) == 42;         // call a function pointer with the 'call' method

foo(1) == 42;               // &lt;- the above de-sugars to this

call(func, 1);              //&lt;- error: 'call (Fn, i64)' is not a registered function

let len = Fn(&quot;len&quot;);        // 'Fn' also works with registered native Rust functions

len.call(&quot;hello&quot;) == 5;

let add = Fn(&quot;+&quot;);          // 'Fn' works with built-in operators also

add.call(40, 2) == 42;

let fn_name = &quot;hello&quot;;      // the function name does not have to exist yet

let hello = Fn(fn_name + &quot;_world&quot;);

hello.call(0);              // error: function not found - 'hello_world (i64)'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#global-namespace-only" id="global-namespace-only">Global Namespace Only</a></h2>
<p>Because of their dynamic nature, function pointers cannot refer to functions in a <em>module</em> <a href="language//rhai/vnext/language/fn-namespaces.html">namespace</a>
(i.e. functions in <a href="language//rhai/vnext/language/modules/import.html"><code>import</code></a>-ed modules).  They can only refer to functions within the global <a href="language//rhai/vnext/language/fn-namespaces.html">namespace</a>.
See <a href="language//rhai/vnext/language/fn-namespaces.html">function namespaces</a> for more details.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>import &quot;foo&quot; as f;          // assume there is 'f::do_something()'

f::do_something();          // works!

let p = Fn(&quot;f::do_something&quot;);

p.call();                   // error: function not found - 'f::do_something'

fn do_something_now() {     // call it from a local function
    import &quot;foo&quot; as f;
    f::do_something();
}

let p = Fn(&quot;do_something_now&quot;);

p.call();                   // works!
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#dynamic-dispatch" id="dynamic-dispatch">Dynamic Dispatch</a></h2>
<p>The purpose of function pointers is to enable rudimentary <em>dynamic dispatch</em>, meaning to determine,
at runtime, which function to call among a group.</p>
<p>Although it is possible to simulate dynamic dispatch via a number and a large <code>if-then-else-if</code> statement,
using function pointers significantly simplifies the code.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = some_calculation();

// These are the functions to call depending on the value of 'x'
fn method1(x) { ... }
fn method2(x) { ... }
fn method3(x) { ... }

// Traditional - using decision variable
let func = sign(x);

// Dispatch with if-statement
if func == -1 {
    method1(42);
} else if func == 0 {
    method2(42);
} else if func == 1 {
    method3(42);
}

// Using pure function pointer
let func = if x &lt; 0 {
    Fn(&quot;method1&quot;)
} else if x == 0 {
    Fn(&quot;method2&quot;)
} else if x &gt; 0 {
    Fn(&quot;method3&quot;)
}

// Dynamic dispatch
func.call(42);

// Using functions map
let map = [ Fn(&quot;method1&quot;), Fn(&quot;method2&quot;), Fn(&quot;method3&quot;) ];

let func = sign(x) + 1;

// Dynamic dispatch
map[func].call(42);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#print-and-debug" id="print-and-debug"><code>print</code> and <code>debug</code></a></h1>
<p>The <code>print</code> and <code>debug</code> functions default to printing to <code>stdout</code>, with <code>debug</code> using standard debug formatting.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>print(&quot;hello&quot;);         // prints hello to stdout

print(1 + 2 + 3);       // prints 6 to stdout

print(&quot;hello&quot; + 42);    // prints hello42 to stdout

debug(&quot;world!&quot;);        // prints &quot;world!&quot; to stdout using debug formatting
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#override-print-and-debug-with-callback-functions" id="override-print-and-debug-with-callback-functions">Override <code>print</code> and <code>debug</code> with Callback Functions</a></h2>
<p>When embedding Rhai into an application, it is usually necessary to trap <code>print</code> and <code>debug</code> output
(for logging into a tracking log, for example) with the <code>Engine::on_print</code> and <code>Engine::on_debug</code> methods:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Any function or closure that takes an '&amp;str' argument can be used to override
// 'print' and 'debug'
engine.on_print(|x| println!(&quot;hello: {}&quot;, x));
engine.on_debug(|x| println!(&quot;DEBUG: {}&quot;, x));

// Example: quick-'n-dirty logging
let logbook = Arc::new(RwLock::new(Vec::&lt;String&gt;::new()));

// Redirect print/debug output to 'log'
let log = logbook.clone();
engine.on_print(move |s| log.write().unwrap().push(format!(&quot;entry: {}&quot;, s)));

let log = logbook.clone();
engine.on_debug(move |s| log.write().unwrap().push(format!(&quot;DEBUG: {}&quot;, s)));

// Evaluate script
engine.eval::&lt;()&gt;(script)?;

// 'logbook' captures all the 'print' and 'debug' output
for entry in logbook.read().unwrap().iter() {
    println!(&quot;{}&quot;, entry);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<p>Rhai allows organizing code (functions, both Rust-based or script-based, and variables) into <em>modules</em>.
Modules can be disabled via the <a href="language/modules//rhai/vnext/start/features.html"><code>no_module</code></a> feature.</p>
<p>A module is of the type <code>Module</code> and encapsulates a Rhai script together with the functions defined
by that script.</p>
<p>The script text is run, variables are then selectively exposed via the <a href="language/modules//rhai/vnext/language/modules/export.html"><code>export</code></a> statement.
Functions defined by the script are automatically exported.</p>
<p>Modules loaded within this module at the global level become <em>sub-modules</em> and are also automatically exported.</p>
<p>Other scripts can then load this module and use the variables and functions exported
as if they were defined inside the same script.</p>
<h1><a class="header" href="#export-variables-functions-and-sub-modules-in-module" id="export-variables-functions-and-sub-modules-in-module">Export Variables, Functions and Sub-Modules in Module</a></h1>
<p>A <em>module</em> is a single script (or pre-compiled <a href="language/modules//rhai/vnext/engine/compile.html"><code>AST</code></a>) containing global variables, functions and sub-modules.</p>
<p>A module can be created from a script via the <code>Module::eval_ast_as_new</code> method. When given an <a href="language/modules//rhai/vnext/engine/compile.html"><code>AST</code></a>,
it is first evaluated, then the following items are exposed as members of the new module:</p>
<ul>
<li>
<p>Global variables - essentially all variables that remain in the <a href="language/modules//rhai/vnext/rust/scope.html"><code>Scope</code></a> at the end of a script run - that are exported. Variables not exported (via the <code>export</code> statement) remain hidden.</p>
</li>
<li>
<p>Functions not specifically marked <code>private</code>.</p>
</li>
<li>
<p>Global modules that remain in the <a href="language/modules//rhai/vnext/rust/scope.html"><code>Scope</code></a> at the end of a script run.</p>
</li>
</ul>
<h2><a class="header" href="#global-variables" id="global-variables">Global Variables</a></h2>
<p>The <code>export</code> statement, which can only be at global level, exposes selected variables as members of a module.</p>
<p>Variables not exported are <em>private</em> and hidden to the outside.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This is a module script.

let private = 123;      // variable not exported - default hidden
let x = 42;             // this will be exported below

export x;               // the variable 'x' is exported under its own name

export x as answer;     // the variable 'x' is exported under the alias 'answer'
                        // another script can load this module and access 'x' as 'module::answer'

{
    let inner = 0;      // local variable - it disappears when the statement block ends,
                        //                  therefore it is not 'global' and is not exported

    export inner;       // exporting an temporary variable has no effect
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#functions-1" id="functions-1">Functions</a></h2>
<p>All functions are automatically exported, <em>unless</em> it is explicitly opt-out with the <a href="language/modules//rhai/vnext/engine/call-fn.html"><code>private</code></a> prefix.</p>
<p>Functions declared <a href="language/modules//rhai/vnext/engine/call-fn.html"><code>private</code></a> are hidden to the outside.</p>
<p>Everything exported from a module is <strong>constant</strong> (<strong>read-only</strong>).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This is a module script.

fn inc(x) { x + 1 }     // script-defined function - default public

private fn foo() {}     // private function - hidden
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#sub-modules" id="sub-modules">Sub-Modules</a></h2>
<p>All loaded modules are automatically exported as sub-modules.</p>
<p>To prevent a module from being exported, load it inside a block statement so that it goes away at the
end of the block.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This is a module script.

import &quot;hello&quot; as foo;      // exported as sub-module 'foo'

{
    import &quot;world&quot; as bar;  // not exported - the module disappears at the end
                            //                of the statement block and is not 'global'
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#import-a-module" id="import-a-module">Import a Module</a></h1>
<h2><a class="header" href="#import-statement" id="import-statement"><code>import</code> Statement</a></h2>
<p>A module can be <em>imported</em> via the <code>import</code> statement, and its members are accessed via ‘<code>::</code>‘ similar to C++.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>import &quot;crypto&quot; as lock;        // import the script file 'crypto.rhai' as a module named 'lock'

lock::encrypt(secret);          // use functions defined under the module via '::'

lock::hash::sha256(key);        // sub-modules are also supported

print(lock::status);            // module variables are constants

lock::status = &quot;off&quot;;           // &lt;- runtime error - cannot modify a constant
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#scoped-imports" id="scoped-imports">Scoped Imports</a></h2>
<p><code>import</code> statements are <em>scoped</em>, meaning that they are only accessible inside the scope that they’re imported.</p>
<p>They can appear anywhere a normal statement can be, but in the vast majority of cases <code>import</code> statements are
group at the beginning of a script. It is not advised to deviate from this common practice unless
there is a <em>Very Good Reason™</em>.</p>
<p>Especially, do not place an <code>import</code> statement within a loop; doing so will repeatedly re-load the same module
during every iteration of the loop!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mod = &quot;crypto&quot;;

if secured {                    // new block scope
    import mod as c;            // import module (the path needs not be a constant string)

    c::encrypt(key);            // use a function in the module
}                               // the module disappears at the end of the block scope

c::encrypt(others);             // &lt;- this causes a run-time error because the 'crypto' module
                                //    is no longer available!

for x in range(0, 1000) {
    import &quot;crypto&quot; as c;       // &lt;- importing a module inside a loop is a Very Bad Idea™

    c.encrypt(something);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#recursive-imports" id="recursive-imports">Recursive Imports</a></h2>
<p>Beware of <em>import cycles</em> - i.e. recursively loading the same module. This is a sure-fire way to
cause a stack overflow in the <a href="language/modules//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>, unless stopped by setting a limit for <a href="language/modules//rhai/vnext/safety/max-modules.html">maximum number of modules</a>.</p>
<p>For instance, importing itself always causes an infinite recursion:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This file is 'hello.rhai'

import &quot;hello&quot; as foo;          // import itself - infinite recursion!

foo::do_something();
<span class="boring">}
</span></code></pre></pre>
<p>Modules cross-referencing also cause infinite recursion:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This file is 'hello.rhai' - references 'world.rhai'
import &quot;world&quot; as foo;
foo::do_something();

// This file is 'world.rhai' - references 'hello.rhai'
import &quot;hello&quot; as bar;
bar::do_something_else();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#create-a-module-from-rust" id="create-a-module-from-rust">Create a Module from Rust</a></h1>
<p>To load a custom module (written in Rust) into an <a href="language/modules//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>, first create a <a href="language/modules//rhai/vnext/language/modules/index.html"><code>Module</code></a> type,
add variables/functions into it, then finally push it into a custom <a href="language/modules//rhai/vnext/rust/scope.html"><code>Scope</code></a>.</p>
<p>This has the equivalent effect of putting an <a href="language/modules//rhai/vnext/language/modules/import.html"><code>import</code></a> statement at the beginning of any script run.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Scope, Module, i64};

let mut engine = Engine::new();
let mut scope = Scope::new();

let mut module = Module::new();             // new module
module.set_var(&quot;answer&quot;, 41_i64);           // variable 'answer' under module
module.set_fn_1(&quot;inc&quot;, |x: i64| Ok(x+1));   // use the 'set_fn_XXX' API to add functions

// Push the module into the custom scope under the name 'question'
// This is equivalent to 'import &quot;...&quot; as question;'
scope.push_module(&quot;question&quot;, module);

// Use module-qualified variables
engine.eval_expression_with_scope::&lt;i64&gt;(&amp;scope, &quot;question::answer + 1&quot;)? == 42;

// Call module-qualified functions
engine.eval_expression_with_scope::&lt;i64&gt;(&amp;scope, &quot;question::inc(question::answer)&quot;)? == 42;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#create-a-module-from-an-ast" id="create-a-module-from-an-ast">Create a Module from an AST</a></h1>
<p>It is easy to convert a pre-compiled <a href="language/modules//rhai/vnext/engine/compile.html"><code>AST</code></a> into a module: just use <code>Module::eval_ast_as_new</code>.</p>
<p>Don’t forget the <a href="language/modules//rhai/vnext/language/modules/export.html"><code>export</code></a> statement, otherwise there will be no variables exposed by the module
other than non-<a href="language/modules//rhai/vnext/engine/call-fn.html"><code>private</code></a> functions (unless that’s intentional).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Module};

let engine = Engine::new();

// Compile a script into an 'AST'
let ast = engine.compile(r#&quot;
    // Functions become module functions
    fn calc(x) {
        x + 1
    }
    fn add_len(x, y) {
        x + y.len
    }

    // Imported modules can become sub-modules
    import &quot;another module&quot; as extra;

    // Variables defined at global level can become module variables
    const x = 123;
    let foo = 41;
    let hello;

    // Variable values become constant module variable values
    foo = calc(foo);
    hello = &quot;hello, &quot; + foo + &quot; worlds!&quot;;

    // Finally, export the variables and modules
    export
        x as abc,           // aliased variable name
        foo,
        hello,
        extra as foobar;    // export sub-module
&quot;#)?;

// Convert the 'AST' into a module, using the 'Engine' to evaluate it first
let module = Module::eval_ast_as_new(Scope::new(), &amp;ast, &amp;engine)?;

// 'module' now can be loaded into a custom 'Scope' for future use.  It contains:
//   - sub-module: 'foobar' (renamed from 'extra')
//   - functions: 'calc', 'add_len'
//   - variables: 'abc' (renamed from 'x'), 'foo', 'hello'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#module-resolvers" id="module-resolvers">Module Resolvers</a></h1>
<p>When encountering an <a href="language/modules//rhai/vnext/language/modules/import.html"><code>import</code></a> statement, Rhai attempts to <em>resolve</em> the module based on the path string.</p>
<p><em>Module Resolvers</em> are service types that implement the <a href="language/modules//rhai/vnext/rust/traits.html"><code>ModuleResolver</code></a> trait.</p>
<p>There are a number of standard resolvers built into Rhai, the default being the <code>FileModuleResolver</code>
which simply loads a script file based on the path (with <code>.rhai</code> extension attached) and execute it to form a module.</p>
<p>Built-in module resolvers are grouped under the <code>rhai::module_resolvers</code> module namespace.</p>
<table><thead><tr><th>Module Resolver</th><th>Description</th></tr></thead><tbody>
<tr><td><code>FileModuleResolver</code></td><td>The default module resolution service, not available under <a href="language/modules//rhai/vnext/start/features.html"><code>no_std</code></a> or <a href="language/modules//rhai/vnext/start/builds/wasm.html">WASM</a> builds. Loads a script file (based off the current directory) with <code>.rhai</code> extension.<br/>The base directory can be changed via the <code>FileModuleResolver::new_with_path()</code> constructor function.<br/><code>FileModuleResolver::create_module()</code> loads a script file and returns a module.</td></tr>
<tr><td><code>StaticModuleResolver</code></td><td>Loads modules that are statically added. This can be used under <a href="language/modules//rhai/vnext/start/features.html"><code>no_std</code></a>.</td></tr>
</tbody></table>
<p>An <a href="language/modules//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>‘s module resolver is set via a call to <code>Engine::set_module_resolver</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Use the 'StaticModuleResolver'
let resolver = rhai::module_resolvers::StaticModuleResolver::new();
engine.set_module_resolver(Some(resolver));

// Effectively disable 'import' statements by setting module resolver to 'None'
engine.set_module_resolver(None);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#implement-a-custom-module-resolver" id="implement-a-custom-module-resolver">Implement a Custom Module Resolver</a></h1>
<p>For many applications in which Rhai is embedded, it is necessary to customize the way that modules
are resolved.  For instance, modules may need to be loaded from script texts stored in a database,
not in the file system.</p>
<p>A module resolver must implement the trait <a href="language/modules//rhai/vnext/rust/traits.html"><code>rhai::ModuleResolver</code></a>,
which contains only one function: <code>resolve</code>.</p>
<p>When Rhai prepares to load a module, <code>ModuleResolver::resolve</code> is called with the name
of the <em>module path</em> (i.e. the path specified in the <a href="language/modules//rhai/vnext/language/modules/import.html"><code>import</code></a> statement). Upon success, it should
return a <a href="language/modules//rhai/vnext/language/modules/index.html"><code>Module</code></a>; if the module cannot be load, return <code>EvalAltResult::ErrorModuleNotFound</code>.</p>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{ModuleResolver, Module, Engine, EvalAltResult};

// Define a custom module resolver.
struct MyModuleResolver {}

// Implement the 'ModuleResolver' trait.
impl ModuleResolver for MyModuleResolver {
    // Only required function.
    fn resolve(
        &amp;self,
        engine: &amp;Engine,    // reference to the current 'Engine'
        path: &amp;str,         // the module path
        pos: Position,      // location of the 'import' statement
    ) -&gt; Result&lt;Module, Box&lt;EvalAltResult&gt;&gt; {
        // Check module path.
        if is_valid_module_path(path) {
            // Load the custom module.
            let module: Module = load_secret_module(path);
            Ok(module)
        } else {
            Err(Box::new(EvalAltResult::ErrorModuleNotFound(path.into(), pos)))
        }
    }
}

let mut engine = Engine::new();

// Set the custom module resolver into the 'Engine'.
engine.set_module_resolver(Some(MyModuleResolver {}));

engine.consume(r#&quot;
    import &quot;hello&quot; as foo;  // this 'import' statement will call
                            // 'MyModuleResolver::resolve' with &quot;hello&quot; as path
    foo:bar();
&quot;#)?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#safety-and-protection-against-dos-attacks" id="safety-and-protection-against-dos-attacks">Safety and Protection Against DoS Attacks</a></h1>
<p>For scripting systems open to untrusted user-land scripts, it is always best to limit the amount of
resources used by a script so that it does not consume more resources that it is allowed to.</p>
<p>The most important resources to watch out for are:</p>
<ul>
<li>
<p><strong>Memory</strong>: A malicious script may continuously grow a <a href="safety//rhai/vnext/language/strings-chars.html">string</a>, an <a href="safety//rhai/vnext/language/arrays.html">array</a> or <a href="safety//rhai/vnext/language/object-maps.html">object map</a> until all memory is consumed.</p>
<p>It may also create a large <a href="safety//rhai/vnext/language/arrays.html">array</a> or <a href="safety//rhai/vnext/language/object-maps.html">object map</a> literal that exhausts all memory during parsing.</p>
</li>
<li>
<p><strong>CPU</strong>: A malicious script may run an infinite tight loop that consumes all CPU cycles.</p>
</li>
<li>
<p><strong>Time</strong>: A malicious script may run indefinitely, thereby blocking the calling system which is waiting for a result.</p>
</li>
<li>
<p><strong>Stack</strong>: A malicious script may attempt an infinite recursive call that exhausts the call stack.</p>
<p>Alternatively, it may create a degenerated deep expression with so many levels that the parser exhausts the call stack
when parsing the expression; or even deeply-nested statement blocks, if nested deep enough.</p>
<p>Another way to cause a stack overflow is to load a <a href="safety//rhai/vnext/language/modules/import.html">self-referencing module</a>.</p>
</li>
<li>
<p><strong>Overflows</strong>: A malicious script may deliberately cause numeric over-flows and/or under-flows, divide by zero, and/or
create bad floating-point representations, in order to crash the system.</p>
</li>
<li>
<p><strong>Files</strong>: A malicious script may continuously <a href="safety//rhai/vnext/language/modules/import.html"><code>import</code></a> an external module within an infinite loop,
thereby putting heavy load on the file-system (or even the network if the file is not local).</p>
<p>Even when modules are not created from files, they still typically consume a lot of resources to load.</p>
</li>
<li>
<p><strong>Data</strong>: A malicious script may attempt to read from and/or write to data that it does not own. If this happens,
it is a severe security breach and may put the entire system at risk.</p>
</li>
</ul>
<h1><a class="header" href="#checked-arithmetic" id="checked-arithmetic">Checked Arithmetic</a></h1>
<p>By default, all arithmetic calculations in Rhai are <em>checked</em>, meaning that the script terminates
with an error whenever it detects a numeric over-flow/under-flow condition or an invalid
floating-point operation, instead of crashing the entire system.</p>
<p>This checking can be turned off via the <a href="safety//rhai/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance
(but higher risks as well).</p>
<h1><a class="header" href="#sand-boxing---block-access-to-external-data" id="sand-boxing---block-access-to-external-data">Sand-Boxing - Block Access to External Data</a></h1>
<p>Rhai is <em>sand-boxed</em> so a script can never read from outside its own environment.</p>
<p>Furthermore, an <a href="safety//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> created non-<code>mut</code> cannot mutate any state outside of itself;
so it is highly recommended that <a href="safety//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>‘s are created immutable as much as possible.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();     // create mutable 'Engine'

engine.register_get(&quot;add&quot;, add);    // configure 'engine'

let engine = engine;                // shadow the variable so that 'engine' is now immutable
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#maximum-length-of-strings" id="maximum-length-of-strings">Maximum Length of Strings</a></h1>
<h2><a class="header" href="#limiting-how-long-strings-can-grow" id="limiting-how-long-strings-can-grow">Limiting How Long Strings Can Grow</a></h2>
<p>Rhai by default does not limit how long a <a href="safety//rhai/vnext/language/strings-chars.html">string</a> can be.</p>
<p>This can be changed via the <code>Engine::set_max_string_size</code> method, with zero being unlimited (the default).</p>
<p>A script attempting to create a string literal longer than the maximum length will terminate with a parse error.</p>
<p>Any script operation that produces a string longer than the maximum also terminates the script with an error result.</p>
<p>This check can be disabled via the <a href="safety//rhai/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_string_size(500);    // allow strings only up to 500 bytes long (in UTF-8 format)

engine.set_max_string_size(0);      // allow unlimited string length
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setting-maximum-length" id="setting-maximum-length">Setting Maximum Length</a></h2>
<p>Be conservative when setting a maximum limit and always consider the fact that a registered function may grow
a string’s length without Rhai noticing until the very end.</p>
<p>For instance, the built-in ‘<code>+</code>‘ operator for strings concatenates two strings together to form one longer string;
if both strings are <em>slightly</em> below the maximum length limit, the resultant string may be almost <em>twice</em> the maximum length.</p>
<h1><a class="header" href="#maximum-size-of-arrays" id="maximum-size-of-arrays">Maximum Size of Arrays</a></h1>
<h2><a class="header" href="#limiting-how-large-arrays-can-grow" id="limiting-how-large-arrays-can-grow">Limiting How Large Arrays Can Grow</a></h2>
<p>Rhai by default does not limit how large an <a href="safety//rhai/vnext/language/arrays.html">array</a> can be.</p>
<p>This can be changed via the <code>Engine::set_max_array_size</code> method, with zero being unlimited (the default).</p>
<p>A script attempting to create an array literal larger than the maximum will terminate with a parse error.</p>
<p>Any script operation that produces an array larger than the maximum also terminates the script with an error result.</p>
<p>This check can be disabled via the <a href="safety//rhai/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_array_size(500);	// allow arrays only up to 500 items

engine.set_max_array_size(0);   // allow unlimited arrays
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setting-maximum-size" id="setting-maximum-size">Setting Maximum Size</a></h2>
<p>Be conservative when setting a maximum limit and always consider the fact that a registered function may grow
an array’s size without Rhai noticing until the very end.</p>
<p>For instance, the built-in ‘<code>+</code>‘ operator for arrays concatenates two arrays together to form one larger array;
if both arrays are <em>slightly</em> below the maximum size limit, the resultant array may be almost <em>twice</em> the maximum size.</p>
<p>As a malicious script may create a deeply-nested array which consumes huge amounts of memory while each individual
array still stays under the maximum size limit, Rhai also recursively adds up the sizes of all <a href="safety//rhai/vnext/language/strings-chars.html">strings</a>, <a href="safety//rhai/vnext/language/arrays.html">arrays</a>
and <a href="safety//rhai/vnext/language/object-maps.html">object maps</a> contained within each array to make sure that the <em>aggregate</em> sizes of none of these data structures
exceed their respective maximum size limits (if any).</p>
<h1><a class="header" href="#maximum-size-of-object-maps" id="maximum-size-of-object-maps">Maximum Size of Object Maps</a></h1>
<h2><a class="header" href="#limiting-how-large-object-maps-can-grow" id="limiting-how-large-object-maps-can-grow">Limiting How Large Object Maps Can Grow</a></h2>
<p>Rhai by default does not limit how large (i.e. the number of properties) an <a href="safety//rhai/vnext/language/object-maps.html">object map</a> can be.</p>
<p>This can be changed via the <code>Engine::set_max_map_size</code> method, with zero being unlimited (the default).</p>
<p>A script attempting to create an object map literal with more properties than the maximum will terminate with a parse error.</p>
<p>Any script operation that produces an object map with more properties than the maximum also terminates the script with an error result.</p>
<p>This check can be disabled via the <a href="safety//rhai/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_map_size(500);   // allow object maps with only up to 500 properties

engine.set_max_map_size(0);     // allow unlimited object maps
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setting-maximum-size-1" id="setting-maximum-size-1">Setting Maximum Size</a></h2>
<p>Be conservative when setting a maximum limit and always consider the fact that a registered function may grow
an object map’s size without Rhai noticing until the very end.</p>
<p>For instance, the built-in ‘<code>+</code>‘ operator for object maps concatenates two object maps together to form one larger object map;
if both object maps are <em>slightly</em> below the maximum size limit, the resultant object map may be almost <em>twice</em> the maximum size.</p>
<p>As a malicious script may create a deeply-nested object map which consumes huge amounts of memory while each individual
object map still stays under the maximum size limit, Rhai also recursively adds up the sizes of all <a href="safety//rhai/vnext/language/strings-chars.html">strings</a>, <a href="safety//rhai/vnext/language/arrays.html">arrays</a>
and <a href="safety//rhai/vnext/language/object-maps.html">object maps</a> contained within each object map to make sure that the <em>aggregate</em> sizes of none of these data structures
exceed their respective maximum size limits (if any).</p>
<h1><a class="header" href="#maximum-number-of-operations" id="maximum-number-of-operations">Maximum Number of Operations</a></h1>
<h2><a class="header" href="#limiting-how-long-a-script-can-run" id="limiting-how-long-a-script-can-run">Limiting How Long a Script Can Run</a></h2>
<p>Rhai by default does not limit how much time or CPU a script consumes.</p>
<p>This can be changed via the <code>Engine::set_max_operations</code> method, with zero being unlimited (the default).</p>
<p>The <em>operations count</em> is intended to be a very course-grained measurement of the amount of CPU that a script
has consumed, allowing the system to impose a hard upper limit on computing resources.</p>
<p>A script exceeding the maximum operations count terminates with an error result.
This can be disabled via the <a href="safety//rhai/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_operations(500); // allow only up to 500 operations for this script

engine.set_max_operations(0);   // allow unlimited operations
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#what-does-one-operation-mean" id="what-does-one-operation-mean">What Does One <em>Operation</em> Mean</a></h2>
<p>The concept of one single <em>operation</em> in Rhai is volatile - it roughly equals one expression node,
loading one variable/constant, one operator call, one iteration of a loop, or one function call etc.
with sub-expressions, statements and function calls executed inside these contexts accumulated on top.</p>
<p>A good rule-of-thumb is that one simple non-trivial expression consumes on average 5-10 operations.</p>
<p>One <em>operation</em> can take an unspecified amount of time and real CPU cycles, depending on the particulars.
For example, loading a constant consumes very few CPU cycles, while calling an external Rust function,
though also counted as only one operation, may consume much more computing resources.</p>
<p>To help visualize, think of an <em>operation</em> as roughly equals to one <em>instruction</em> of a hypothetical CPU
which includes <em>specialized</em> instructions, such as <em>function call</em>, <em>load module</em> etc., each taking up
one CPU cycle to execute.</p>
<h1><a class="header" href="#tracking-progress-and-force-termination" id="tracking-progress-and-force-termination">Tracking Progress and Force-Termination</a></h1>
<p>It is impossible to know when, or even whether, a script run will end
(a.k.a. the <a href="http://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>).</p>
<p>When dealing with third-party untrusted scripts that may be malicious, to track evaluation progress and
to force-terminate a script prematurely (for any reason), provide a closure to the <code>Engine::on_progress</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.on_progress(|&amp;count| {   // parameter is '&amp;u64' - number of operations already performed
    if count % 1000 == 0 {
        println!(&quot;{}&quot;, count);  // print out a progress log every 1,000 operations
    }
    true                        // return 'true' to continue running the script
                                // return 'false' to immediately terminate the script
});
<span class="boring">}
</span></code></pre></pre>
<p>The closure passed to <code>Engine::on_progress</code> will be called once for every operation.
Return <code>false</code> to terminate the script immediately.</p>
<h2><a class="header" href="#operations-count-vs-progress-percentage" id="operations-count-vs-progress-percentage">Operations Count vs. Progress Percentage</a></h2>
<p>Notice that the <em>operations count</em> value passed into the closure does not indicate the <em>percentage</em> of work
already done by the script (and thus it is not real <em>progress</em> tracking), because it is impossible to determine
how long a script may run.  It is possible, however, to calculate this percentage based on an estimated
total number of operations for a typical run.</p>
<h1><a class="header" href="#maximum-number-of-modules" id="maximum-number-of-modules">Maximum Number of Modules</a></h1>
<p>Rhai by default does not limit how many <a href="safety//rhai/vnext/language/modules/index.html">modules</a> can be loaded via <a href="safety//rhai/vnext/language/modules/import.html"><code>import</code></a> statements.</p>
<p>This can be changed via the <code>Engine::set_max_modules</code> method. Notice that setting the maximum number
of modules to zero does <em>not</em> indicate unlimited modules, but disallows loading any module altogether.</p>
<p>A script attempting to load more than the maximum number of modules will terminate with an error result.</p>
<p>This limit can also be used to stop <a href="safety//rhai/vnext/language/modules/import.html"><code>import</code>-loops</a> (i.e. cycles of modules referring to each other).</p>
<p>This check can be disabled via the <a href="safety//rhai/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance
(but higher risks as well).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_modules(5);      // allow loading only up to 5 modules

engine.set_max_modules(0);      // disallow loading any module (maximum = zero)

engine.set_max_modules(1000);   // set to a large number for effectively unlimited modules
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#maximum-call-stack-depth" id="maximum-call-stack-depth">Maximum Call Stack Depth</a></h1>
<h2><a class="header" href="#limiting-how-stack-usage-by-scripts" id="limiting-how-stack-usage-by-scripts">Limiting How Stack Usage by Scripts</a></h2>
<p>Rhai by default limits function calls to a maximum depth of 128 levels (16 levels in debug build).</p>
<p>This limit may be changed via the <code>Engine::set_max_call_levels</code> method.</p>
<p>A script exceeding the maximum call stack depth will terminate with an error result.</p>
<p>This check can be disabled via the <a href="safety//rhai/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_call_levels(10); // allow only up to 10 levels of function calls

engine.set_max_call_levels(0);  // allow no function calls at all (max depth = zero)
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setting-maximum-stack-depth" id="setting-maximum-stack-depth">Setting Maximum Stack Depth</a></h2>
<p>When setting this limit, care must be also taken to the evaluation depth of each <em>statement</em>
within a function. It is entirely possible for a malicious script to embed a recursive call deep
inside a nested expression or statement block (see <a href="safety//rhai/vnext/safety/max-stmt-depth.html">maximum statement depth</a>).</p>
<h1><a class="header" href="#maximum-statement-depth" id="maximum-statement-depth">Maximum Statement Depth</a></h1>
<h2><a class="header" href="#limiting-how-deeply-nested-a-statement-can-be" id="limiting-how-deeply-nested-a-statement-can-be">Limiting How Deeply-Nested a Statement Can Be</a></h2>
<p>Rhai by default limits statements and expressions nesting to a maximum depth of 128
(which should be plenty) when they are at <em>global</em> level, but only a depth of 32
when they are within function bodies.</p>
<p>For debug builds, these limits are set further downwards to 32 and 16 respectively.</p>
<p>That is because it is possible to overflow the <a href="safety//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>‘s stack when it tries to
recursively parse an extremely deeply-nested code stream.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// The following, if long enough, can easily cause stack overflow during parsing.
let a = (1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(...)+1)))))))))));
<span class="boring">}
</span></code></pre></pre>
<p>This limit may be changed via the <code>Engine::set_max_expr_depths</code> method.</p>
<p>There are two limits to set, one for the maximum depth at global level, and the other for function bodies.</p>
<p>A script exceeding the maximum nesting depths will terminate with a parsing error.
The malicious <a href="safety//rhai/vnext/engine/compile.html"><code>AST</code></a> will not be able to get past parsing in the first place.</p>
<p>This check can be disabled via the <a href="safety//rhai/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_expr_depths(50, 5);  // allow nesting up to 50 layers of expressions/statements
                                    // at global level, but only 5 inside functions
<span class="boring">}
</span></code></pre></pre>
<p>Beware that there may be multiple layers for a simple language construct, even though it may correspond
to only one AST node. That is because the Rhai <em>parser</em> internally runs a recursive chain of function calls
and it is important that a malicious script does not panic the parser in the first place.</p>
<h2><a class="header" href="#beware-of-recursion" id="beware-of-recursion">Beware of Recursion</a></h2>
<p><em>Functions</em> are placed under stricter limits because of the multiplicative effect of <em>recursion</em>.</p>
<p>A script can effectively call itself while deep inside an expression chain within the function body,
thereby overflowing the stack even when the level of recursion is within limit.</p>
<p>In general, make sure that <code>C x ( 5 + F ) + S</code> layered calls do not cause a stack overflow, where:</p>
<ul>
<li><code>C</code> = maximum call stack depth,</li>
<li><code>F</code> = maximum statement depth for functions,</li>
<li><code>S</code> = maximum statement depth at global level.</li>
</ul>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced Topics</a></h1>
<p>This section covers advanced features such as:</p>
<ul>
<li>
<p><a href="/rhai/vnext/engine/optimize/index.html">Script optimization</a></p>
</li>
<li>
<p>The dreaded (or beloved for those with twisted tastes) <a href="/rhai/vnext/language/eval.html"><code>eval</code></a> statement</p>
</li>
</ul>
<h1><a class="header" href="#object-oriented-programming-oop" id="object-oriented-programming-oop">Object-Oriented Programming (OOP)</a></h1>
<p>Rhai does not have <em>objects</em> per se, but it is possible to <em>simulate</em> object-oriented programming.</p>
<h2><a class="header" href="#use-a-hreflanguagerhaivnextlanguageobject-mapshtmlobject-mapsa-to-simulate-oop" id="use-a-hreflanguagerhaivnextlanguageobject-mapshtmlobject-mapsa-to-simulate-oop">Use <a href="language//rhai/vnext/language/object-maps.html">Object Maps</a> to Simulate OOP</a></h2>
<p>Rhai’s <a href="language//rhai/vnext/language/object-maps.html">object maps</a> has <a href="language//rhai/vnext/language/object-maps-oop.html">special support for OOP</a>.</p>
<table><thead><tr><th>Rhai concept</th><th align="center">Maps to OOP</th></tr></thead><tbody>
<tr><td><a href="language//rhai/vnext/language/object-maps.html">Object maps</a></td><td align="center">objects</td></tr>
<tr><td><a href="language//rhai/vnext/language/object-maps.html">Object map</a> properties holding values</td><td align="center">properties</td></tr>
<tr><td><a href="language//rhai/vnext/language/object-maps.html">Object map</a> properties that hold <a href="language//rhai/vnext/language/fn-ptr.html">function pointers</a></td><td align="center">methods</td></tr>
</tbody></table>
<h2><a class="header" href="#examples-7" id="examples-7">Examples</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Define the object
let obj = #{
                data: 0,
                increment: Fn(&quot;add&quot;),       // when called, 'this' binds to 'obj'
                update: Fn(&quot;update&quot;),       // when called, 'this' binds to 'obj'
                action: Fn(&quot;action&quot;)        // when called, 'this' binds to 'obj'
           };

// Define functions
fn add(x)       { this.data += x; }         // update using 'this'
fn update(x)    { this.data = x; }          // update using 'this'
fn action()     { print(this.data); }       // access properties of 'this'

// Use the object
obj.increment(1);
obj.action();                               // prints 1

obj.update(42);
obj.action();                               // prints 42
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#serialization-and-deserialization-of-dynamic-with-serde" id="serialization-and-deserialization-of-dynamic-with-serde">Serialization and Deserialization of <code>Dynamic</code> with <code>serde</code></a></h1>
<p>Rhai’s <a href="rust//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> type supports serialization and deserialization by <a href="https://crates.io/crates/serde"><code>serde</code></a>
via the <a href="rust//rhai/vnext/start/features.html"><code>serde</code></a> feature.</p>
<p>A <a href="rust//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> can be seamlessly converted to and from a type that implements <code>serde::Serialize</code> and/or
<code>serde::Deserialize</code>.</p>
<h2><a class="header" href="#serialization" id="serialization">Serialization</a></h2>
<p>While it is simple to serialize a Rust type to <code>JSON</code> via <code>serde</code>,
then use <a href="rust//rhai/vnext/language/json.html"><code>Engine::parse_json</code></a> to convert it into an <a href="rust//rhai/vnext/language/object-maps.html">object map</a>,
Rhai supports serializing a <a href="rust//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> directly via <code>serde</code> without going through the <code>JSON</code> step.</p>
<p>The function <code>rhai::ser::to_dynamic</code> automatically converts any Rust type that implements <code>serde::Serialize</code>
into a <a href="rust//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a>.</p>
<p>In particular, Rust <code>struct</code>‘s (or any type that is marked as a <code>serde</code> map) are converted into <a href="rust//rhai/vnext/language/object-maps.html">object maps</a>
while Rust <code>Vec</code>‘s (or any type that is marked as a <code>serde</code> sequence) are converted into <a href="rust//rhai/vnext/language/arrays.html">arrays</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Dynamic, Map};
use rhai::ser::to_dynamic;

#[derive(Debug, serde::Serialize)]
struct Point {
    x: f64,
    y: f64
}

#[derive(Debug, serde::Serialize)]
struct MyStruct {
    a: i64,
    b: Vec&lt;String&gt;,
    c: bool,
    d: Point
}

let x = MyStruct {
    a: 42,
    b: vec![ &quot;hello&quot;.into(), &quot;world&quot;.into() ],
    c: true,
    d: Point { x: 123.456, y: 999.0 }
};

// Convert the 'MyStruct' into a 'Dynamic'
let map: Dynamic = to_dynamic(x);

map.is::&lt;Map&gt;() == true;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#deserialization" id="deserialization">Deserialization</a></h2>
<p>The function <code>rhai::de::from_dynamic</code> automatically converts a <a href="rust//rhai/vnext/language/dynamic.html"><code>Dynamic</code></a> value into any Rust type
that implements <code>serde::Deserialize</code>.</p>
<p>In particular, <a href="rust//rhai/vnext/language/object-maps.html">object maps</a> are converted into Rust <code>struct</code>‘s (or any type that is marked as
a <code>serde</code> map) while <a href="rust//rhai/vnext/language/arrays.html">arrays</a> are converted into Rust <code>Vec</code>‘s (or any type that is marked
as a <code>serde</code> sequence).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Dynamic};
use rhai::de::from_dynamic;

#[derive(Debug, serde::Deserialize)]
struct Point {
    x: f64,
    y: f64
}

#[derive(Debug, serde::Deserialize)]
struct MyStruct {
    a: i64,
    b: Vec&lt;String&gt;,
    c: bool,
    d: Point
}

let engine = Engine::new();

let result: Dynamic = engine.eval(r#&quot;
<span class="boring">            {
</span>                a: 42,
                b: [ &quot;hello&quot;, &quot;world&quot; ],
                c: true,
                d: #{ x: 123.456, y: 999.0 }
            }
        &quot;#)?;

// Convert the 'Dynamic' object map into 'MyStruct'
let x: MyStruct = from_dynamic(&amp;result)?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#script-optimization" id="script-optimization">Script Optimization</a></h1>
<p>Rhai includes an <em>optimizer</em> that tries to optimize a script after parsing.
This can reduce resource utilization and increase execution speed.</p>
<p>Script optimization can be turned off via the <a href="engine/optimize//rhai/vnext/start/features.html"><code>no_optimize</code></a> feature.</p>
<h2><a class="header" href="#dead-code-removal" id="dead-code-removal">Dead Code Removal</a></h2>
<p>For example, in the following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let x = 999;            // NOT eliminated: variable may be used later on (perhaps even an 'eval')
    123;                    // eliminated: no effect
    &quot;hello&quot;;                // eliminated: no effect
    [1, 2, x, x*2, 5];      // eliminated: no effect
    foo(42);                // NOT eliminated: the function 'foo' may have side-effects
    666                     // NOT eliminated: this is the return value of the block,
                            // and the block is the last one so this is the return value of the whole script
}
<span class="boring">}
</span></code></pre></pre>
<p>Rhai attempts to eliminate <em>dead code</em> (i.e. code that does nothing, for example an expression by itself as a statement,
which is allowed in Rhai).</p>
<p>The above script optimizes to:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let x = 999;
    foo(42);
    666
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#constants-propagation" id="constants-propagation">Constants Propagation</a></h2>
<p>Constants propagation is used to remove dead code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const ABC = true;
if ABC || some_work() { print(&quot;done!&quot;); }   // 'ABC' is constant so it is replaced by 'true'...
if true || some_work() { print(&quot;done!&quot;); }  // since '||' short-circuits, 'some_work' is never called
if true { print(&quot;done!&quot;); }                 // &lt;- the line above is equivalent to this
print(&quot;done!&quot;);                             // &lt;- the line above is further simplified to this
                                            //    because the condition is always true
<span class="boring">}
</span></code></pre></pre>
<p>These are quite effective for template-based machine-generated scripts where certain constant values
are spliced into the script text in order to turn on/off certain sections.</p>
<p>For fixed script texts, the constant values can be provided in a user-defined <a href="engine/optimize//rhai/vnext/rust/scope.html"><code>Scope</code></a> object
to the <a href="engine/optimize//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> for use in compilation and evaluation.</p>
<h2><a class="header" href="#watch-out-for-function-calls" id="watch-out-for-function-calls">Watch Out for Function Calls</a></h2>
<p>Beware, however, that most operators are actually function calls, and those functions can be overridden,
so they are not optimized away:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const DECISION = 1;

if DECISION == 1 {          // NOT optimized away because you can define
    :                       // your own '==' function to override the built-in default!
    :
} else if DECISION == 2 {   // same here, NOT optimized away
    :
} else if DECISION == 3 {   // same here, NOT optimized away
    :
} else {
    :
}
<span class="boring">}
</span></code></pre></pre>
<p>because no operator functions will be run (in order not to trigger side-effects) during the optimization process
(unless the optimization level is set to <a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>).</p>
<p>So, instead, do this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const DECISION_1 = true;
const DECISION_2 = false;
const DECISION_3 = false;

if DECISION_1 {
    :                       // this branch is kept and promoted to the parent level
} else if DECISION_2 {
    :                       // this branch is eliminated
} else if DECISION_3 {
    :                       // this branch is eliminated
} else {
    :                       // this branch is eliminated
}
<span class="boring">}
</span></code></pre></pre>
<p>In general, boolean constants are most effective for the optimizer to automatically prune
large <code>if</code>-<code>else</code> branches because they do not depend on operators.</p>
<p>Alternatively, turn the optimizer to <a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>.</p>
<h1><a class="header" href="#optimization-levels" id="optimization-levels">Optimization Levels</a></h1>
<p>There are three levels of optimization: <code>None</code>, <code>Simple</code> and <code>Full</code>.</p>
<ul>
<li>
<p><code>None</code> is obvious - no optimization on the AST is performed.</p>
</li>
<li>
<p><code>Simple</code> (default) performs only relatively <em>safe</em> optimizations without causing side-effects
(i.e. it only relies on static analysis and will not actually perform any function calls).</p>
</li>
<li>
<p><code>Full</code> is <em>much</em> more aggressive, <em>including</em> running functions on constant arguments to determine their result.
One benefit to this is that many more optimization opportunities arise, especially with regards to comparison operators.</p>
</li>
</ul>
<h2><a class="header" href="#set-optimization-level" id="set-optimization-level">Set Optimization Level</a></h2>
<p>An <a href="engine/optimize//rhai/vnext/engine/hello-world.html"><code>Engine</code></a>‘s optimization level is set via a call to <code>Engine::set_optimization_level</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Turn on aggressive optimizations
engine.set_optimization_level(rhai::OptimizationLevel::Full);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#re-optimize-an-ast" id="re-optimize-an-ast">Re-Optimize an AST</a></h1>
<p>Sometimes it is more efficient to store one single, large script with delimited code blocks guarded by
constant variables.  This script is compiled once to an <a href="engine/optimize//rhai/vnext/engine/compile.html"><code>AST</code></a>.</p>
<p>Then, depending on the execution environment, constants are passed into the <a href="engine/optimize//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> and the <a href="engine/optimize//rhai/vnext/engine/compile.html"><code>AST</code></a>
is <em>re</em>-optimized based on those constants via the <code>Engine::optimize_ast</code> method,
effectively pruning out unused code sections.</p>
<p>The final, optimized <a href="engine/optimize//rhai/vnext/engine/compile.html"><code>AST</code></a> is then used for evaluations.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Compile master script to AST
let master_ast = engine.compile(
r&quot;
    if SCENARIO_1 {
        do_work();
    } else if SCENARIO_2 {
        do_something();
    } else if SCENARIO_3 {
        do_something_else();
    } else {
        do_nothing();
    }
&quot;)?;

// Create a new 'Scope' - put constants in it to aid optimization
let mut scope = Scope::new();
scope.push_constant(&quot;SCENARIO_1&quot;, true);
scope.push_constant(&quot;SCENARIO_2&quot;, false);
scope.push_constant(&quot;SCENARIO_3&quot;, false);

// Re-optimize the AST
let new_ast = engine.optimize_ast(&amp;scope, master_ast.clone(), OptimizationLevel::Simple);

// 'new_ast' is essentially: 'do_work()'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#eager-function-evaluation-when-using-full-optimization-level" id="eager-function-evaluation-when-using-full-optimization-level">Eager Function Evaluation When Using Full Optimization Level</a></h1>
<p>When the optimization level is <a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>, the <a href="engine/optimize//rhai/vnext/engine/hello-world.html"><code>Engine</code></a> assumes all functions to be <em>pure</em> and will <em>eagerly</em>
evaluated all function calls with constant arguments, using the result to replace the call.</p>
<p>This also applies to all operators (which are implemented as functions).</p>
<p>For instance, the same example above:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// When compiling the following with OptimizationLevel::Full...

const DECISION = 1;
                            // this condition is now eliminated because 'DECISION == 1'
if DECISION == 1 {          // is a function call to the '==' function, and it returns 'true'
    print(&quot;hello!&quot;);        // this block is promoted to the parent level
} else {
    print(&quot;boo!&quot;);          // this block is eliminated because it is never reached
}

print(&quot;hello!&quot;);            // &lt;- the above is equivalent to this
                            //    ('print' and 'debug' are handled specially)
<span class="boring">}
</span></code></pre></pre>
<p>Because of the eager evaluation of functions, many constant expressions will be evaluated and replaced by the result.
This does not happen with <a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Simple</code></a> which doesn’t assume all functions to be <em>pure</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// When compiling the following with OptimizationLevel::Full...

let x = (1+2)*3-4/5%6;      // &lt;- will be replaced by 'let x = 9'
let y = (1&gt;2) || (3&lt;=4);    // &lt;- will be replaced by 'let y = true'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#side-effect-considerations-for-full-optimization-level" id="side-effect-considerations-for-full-optimization-level">Side-Effect Considerations for Full Optimization Level</a></h1>
<p>All of Rhai’s built-in functions (and operators which are implemented as functions) are <em>pure</em> (i.e. they do not mutate state
nor cause any side-effects, with the exception of <code>print</code> and <code>debug</code> which are handled specially) so using
<a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a> is usually quite safe <em>unless</em> custom types and functions are registered.</p>
<p>If custom functions are registered, they <em>may</em> be called (or maybe not, if the calls happen to lie within a pruned code block).</p>
<p>If custom functions are registered to overload built-in operators, they will also be called when the operators are used
(in an <code>if</code> statement, for example) causing side-effects.</p>
<p>Therefore, the rule-of-thumb is:</p>
<ul>
<li>
<p><em>Always</em> register custom types and functions <em>after</em> compiling scripts if <a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a> is used.</p>
</li>
<li>
<p><em>DO NOT</em> depend on knowledge that the functions have no side-effects, because those functions can change later on and, when that happens, existing scripts may break in subtle ways.</p>
</li>
</ul>
<h1><a class="header" href="#volatility-considerations-for-full-optimization-level" id="volatility-considerations-for-full-optimization-level">Volatility Considerations for Full Optimization Level</a></h1>
<p>Even if a custom function does not mutate state nor cause side-effects, it may still be <em>volatile</em>,
i.e. it <em>depends</em> on the external environment and is not <em>pure</em>.</p>
<p>A perfect example is a function that gets the current time - obviously each run will return a different value!</p>
<p>The optimizer, when using <a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>, will <em>merrily assume</em> that all functions are <em>pure</em>,
so when it finds constant arguments (or none) it eagerly executes the function call and replaces it with the result.</p>
<p>This causes the script to behave differently from the intended semantics.</p>
<p>Therefore, <strong>avoid using <a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a></strong> if non-<em>pure</em> custom types and/or functions are involved.</p>
<h1><a class="header" href="#subtle-semantic-changes-after-optimization" id="subtle-semantic-changes-after-optimization">Subtle Semantic Changes After Optimization</a></h1>
<p>Some optimizations can alter subtle semantics of the script.</p>
<p>For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>if true {                   // condition always true
    123.456;                // eliminated
    hello;                  // eliminated, EVEN THOUGH the variable doesn't exist!
    foo(42)                 // promoted up-level
}

foo(42)                     // &lt;- the above optimizes to this
<span class="boring">}
</span></code></pre></pre>
<p>If the original script were evaluated instead, it would have been an error - the variable <code>hello</code> does not exist,
so the script would have been terminated at that point with an error return.</p>
<p>In fact, any errors inside a statement that has been eliminated will silently <em>disappear</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>print(&quot;start!&quot;);
if my_decision { /* do nothing... */ }  // eliminated due to no effect
print(&quot;end!&quot;);

// The above optimizes to:

print(&quot;start!&quot;);
print(&quot;end!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>In the script above, if <code>my_decision</code> holds anything other than a boolean value,
the script should have been terminated due to a type error.</p>
<p>However, after optimization, the entire <code>if</code> statement is removed (because an access to <code>my_decision</code> produces
no side-effects), thus the script silently runs to completion without errors.</p>
<p>It is usually a <em>Very Bad Idea™</em> to depend on a script failing or such kind of subtleties, but if it turns out to be necessary
(why? I would never guess), turn script optimization off by setting the optimization level to <a href="engine/optimize//rhai/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::None</code></a>.</p>
<h1><a class="header" href="#eval-statement" id="eval-statement"><code>eval</code> Statement</a></h1>
<h2><a class="header" href="#or-how-to-shoot-yourself-in-the-foot-even-easier" id="or-how-to-shoot-yourself-in-the-foot-even-easier">Or “How to Shoot Yourself in the Foot even Easier”</a></h2>
<p>Saving the best for last, there is the ever-dreaded... <code>eval</code> function!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 10;

fn foo(x) { x += 12; x }

let script = &quot;let y = x;&quot;;      // build a script
script +=    &quot;y += foo(y);&quot;;
script +=    &quot;x + y&quot;;

let result = eval(script);      // &lt;- look, JavaScript, we can also do this!

print(&quot;Answer: &quot; + result);     // prints 42

print(&quot;x = &quot; + x);              // prints 10: functions call arguments are passed by value
print(&quot;y = &quot; + y);              // prints 32: variables defined in 'eval' persist!

eval(&quot;{ let z = y }&quot;);          // to keep a variable local, use a statement block

print(&quot;z = &quot; + z);              // &lt;- error: variable 'z' not found

&quot;print(42)&quot;.eval();             // &lt;- nope... method-call style doesn't work with 'eval'
<span class="boring">}
</span></code></pre></pre>
<p>Script segments passed to <code>eval</code> execute inside the current <a href="language//rhai/vnext/rust/scope.html"><code>Scope</code></a>, so they can access and modify <em>everything</em>,
including all variables that are visible at that position in code! It is almost as if the script segments were
physically pasted in at the position of the <code>eval</code> call.</p>
<h2><a class="header" href="#cannot-define-new-functions" id="cannot-define-new-functions">Cannot Define New Functions</a></h2>
<p>New functions cannot be defined within an <code>eval</code> call, since functions can only be defined at the <em>global</em> level,
not inside another function call!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let script = &quot;x += 32&quot;;
let x = 10;
eval(script);                   // variable 'x' in the current scope is visible!
print(x);                       // prints 42

// The above is equivalent to:
let script = &quot;x += 32&quot;;
let x = 10;
x += 32;
print(x);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#eval-is-evil" id="eval-is-evil"><code>eval</code> is Evil</a></h2>
<p>For those who subscribe to the (very sensible) motto of <a href="http://linterrors.com/js/eval-is-evil">“<code>eval</code> is evil”</a>,
disable <code>eval</code> by overloading it, probably with something that throws.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn eval(script) { throw &quot;eval is evil! I refuse to run &quot; + script }

let x = eval(&quot;40 + 2&quot;);         // 'eval' here throws &quot;eval is evil! I refuse to run 40 + 2&quot;
<span class="boring">}
</span></code></pre></pre>
<p>Or overload it from Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn alt_eval(script: String) -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt; {
    Err(format!(&quot;eval is evil! I refuse to run {}&quot;, script).into())
}

engine.register_result_fn(&quot;eval&quot;, alt_eval);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#evalpackage" id="evalpackage"><code>EvalPackage</code></a></h2>
<p>There is even a package named <a href="language//rhai/vnext/rust/packages/index.html"><code>EvalPackage</code></a> which implements the disabling override:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rhai::Engine;
use rhai::packages::Package             // load the 'Package' trait to use packages
use rhai::packages::EvalPackage;        // the 'eval' package disables 'eval'

let mut engine = Engine::new();
let package = EvalPackage::new();       // create the package

engine.load_package(package.get());     // load the package
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>This section contains miscellaneous reference materials.</p>
<h1><a class="header" href="#keywords-list" id="keywords-list">Keywords List</a></h1>
<table><thead><tr><th align="center">Keyword</th><th>Description</th><th align="center">Not available under</th></tr></thead><tbody>
<tr><td align="center"><code>true</code></td><td>Boolean true literal</td><td align="center"></td></tr>
<tr><td align="center"><code>false</code></td><td>Boolean false literal</td><td align="center"></td></tr>
<tr><td align="center"><code>let</code></td><td>Variable declaration</td><td align="center"></td></tr>
<tr><td align="center"><code>const</code></td><td>Constant declaration</td><td align="center"></td></tr>
<tr><td align="center"><code>if</code></td><td>If statement</td><td align="center"></td></tr>
<tr><td align="center"><code>else</code></td><td>else block of if statement</td><td align="center"></td></tr>
<tr><td align="center"><code>while</code></td><td>While loop</td><td align="center"></td></tr>
<tr><td align="center"><code>loop</code></td><td>Infinite loop</td><td align="center"></td></tr>
<tr><td align="center"><code>for</code></td><td>For loop</td><td align="center"></td></tr>
<tr><td align="center"><code>in</code></td><td>Containment test, part of for loop</td><td align="center"></td></tr>
<tr><td align="center"><code>continue</code></td><td>Continue a loop at the next iteration</td><td align="center"></td></tr>
<tr><td align="center"><code>break</code></td><td>Loop breaking</td><td align="center"></td></tr>
<tr><td align="center"><code>return</code></td><td>Return value</td><td align="center"></td></tr>
<tr><td align="center"><code>throw</code></td><td>Throw exception</td><td align="center"></td></tr>
<tr><td align="center"><code>import</code></td><td>Import module</td><td align="center"><a href="appendix//rhai/vnext/start/features.html"><code>no_module</code></a></td></tr>
<tr><td align="center"><code>export</code></td><td>Export variable</td><td align="center"><a href="appendix//rhai/vnext/start/features.html"><code>no_module</code></a></td></tr>
<tr><td align="center"><code>as</code></td><td>Alias for variable export</td><td align="center"><a href="appendix//rhai/vnext/start/features.html"><code>no_module</code></a></td></tr>
<tr><td align="center"><code>private</code></td><td>Mark function private</td><td align="center"><a href="appendix//rhai/vnext/start/features.html"><code>no_function</code></a></td></tr>
<tr><td align="center"><code>fn</code> (lower-case <code>f</code>)</td><td>Function definition</td><td align="center"><a href="appendix//rhai/vnext/start/features.html"><code>no_function</code></a></td></tr>
<tr><td align="center"><code>Fn</code> (capital <code>F</code>)</td><td>Function to create a <a href="appendix//rhai/vnext/language/fn-ptr.html">function pointer</a></td><td align="center"></td></tr>
<tr><td align="center"><code>call</code></td><td>Call a <a href="appendix//rhai/vnext/language/fn-ptr.html">function pointer</a></td><td align="center"></td></tr>
<tr><td align="center"><code>this</code></td><td>Reference to base object for method call</td><td align="center"><a href="appendix//rhai/vnext/start/features.html"><code>no_function</code></a></td></tr>
<tr><td align="center"><code>type_of</code></td><td>Get type name of value</td><td align="center"></td></tr>
<tr><td align="center"><code>print</code></td><td>Print value</td><td align="center"></td></tr>
<tr><td align="center"><code>debug</code></td><td>Print value in debug format</td><td align="center"></td></tr>
<tr><td align="center"><code>eval</code></td><td>Evaluate script</td><td align="center"></td></tr>
</tbody></table>
<h1><a class="header" href="#operators" id="operators">Operators</a></h1>
<table><thead><tr><th align="center">Operator</th><th>Description</th><th align="center">Binary?</th></tr></thead><tbody>
<tr><td align="center"><code>+</code></td><td>Add</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>-</code></td><td>Subtract, Minus</td><td align="center">Yes/No</td></tr>
<tr><td align="center"><code>*</code></td><td>Multiply</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>/</code></td><td>Divide</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>%</code></td><td>Modulo</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>~</code></td><td>Power</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&gt;&gt;</code></td><td>Right bit-shift</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&lt;&lt;</code></td><td>Left bit-shift</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&amp;</code></td><td>Bit-wise <em>And</em>, Boolean <em>And</em></td><td align="center">Yes</td></tr>
<tr><td align="center"><code>|</code></td><td>Bit-wise <em>Or</em>, Boolean <em>Or</em></td><td align="center">Yes</td></tr>
<tr><td align="center"><code>^</code></td><td>Bit-wise <em>Xor</em></td><td align="center">Yes</td></tr>
<tr><td align="center"><code>==</code></td><td>Equals to</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>~=</code></td><td>Not equals to</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&gt;</code></td><td>Greater than</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&gt;=</code></td><td>Greater than or equals to</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&lt;</code></td><td>Less than</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&lt;=</code></td><td>Less than or equals to</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&gt;=</code></td><td>Greater than or equals to</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>&amp;&amp;</code></td><td>Boolean <em>And</em> (short-circuits)</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>||</code></td><td>Boolean <em>Or</em> (short-circuits)</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>!</code></td><td>Boolean <em>Not</em></td><td align="center">No</td></tr>
<tr><td align="center"><code>[</code> .. <code>]</code></td><td>Indexing</td><td align="center">Yes</td></tr>
<tr><td align="center"><code>.</code></td><td>Property access, Method call</td><td align="center">Yes</td></tr>
</tbody></table>
<h1><a class="header" href="#literals-syntax" id="literals-syntax">Literals Syntax</a></h1>
<table><thead><tr><th align="center">Type</th><th align="center">Literal syntax</th></tr></thead><tbody>
<tr><td align="center"><code>INT</code></td><td align="center"><code>42</code>, <code>-123</code>, <code>0</code>,<br/><code>0x????..</code> (hex), <code>0b????..</code> (binary), <code>0o????..</code> (octal)</td></tr>
<tr><td align="center"><code>FLOAT</code></td><td align="center"><code>42.0</code>, <code>-123.456</code>, <code>0.0</code></td></tr>
<tr><td align="center"><a href="appendix//rhai/vnext/language/strings-chars.html">String</a></td><td align="center"><code>&quot;... \x?? \u???? \U???????? ...&quot;</code></td></tr>
<tr><td align="center">Character</td><td align="center"><code>&quot;... \x?? \u???? \U???????? ...&quot;</code></td></tr>
<tr><td align="center"><a href="appendix//rhai/vnext/language/arrays.html"><code>Array</code></a></td><td align="center"><code>[ ???, ???, ??? ]</code></td></tr>
<tr><td align="center"><a href="appendix//rhai/vnext/language/object-maps.html">Object map</a></td><td align="center"><code>#{ a: ???, b: ???, c: ???, &quot;def&quot;: ??? }</code></td></tr>
<tr><td align="center">Boolean true</td><td align="center"><code>true</code></td></tr>
<tr><td align="center">Boolean false</td><td align="center"><code>false</code></td></tr>
<tr><td align="center"><code>Nothing</code>/<code>null</code>/<code>nil</code>/<code>void</code>/Unit</td><td align="center"><code>()</code></td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
